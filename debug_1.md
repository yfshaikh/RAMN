# Debugging UART output in Renode setup
_Exported on 10/21/2025 at 12:13:35 CDT from Cursor (1.7.52)_

---

**User**

This is where I'm at, from another chat. Do you understand the situation?

Here‚Äôs a full summary you can hand off to a new LLM so they understand exactly where you‚Äôre at and what‚Äôs been done so far:

üéØ Goal

You (Yusuf) are running Toyota‚Äôs RAMN firmware on Renode (on macOS) to emulate the STM32L552-based ECUs.
You want to:

Boot the RAMN firmware ELF file in Renode,

See its serial (UART) debug output, and

Eventually simulate the multi-ECU architecture (e.g., CAN communication).

You already built the firmware ELF in STM32CubeIDE, and it runs without errors in Renode, but no UART output was appearing.

üß© What You Started With

Two Renode scripts from your friend:

stm32l552_ramn_custom.repl ‚Üí describes the STM32L552 platform.

ramn.resc ‚Üí load script for the RAMN ELF.

You built your own ELF (RAMNV1.elf) successfully using STM32CubeIDE.

You‚Äôre on macOS, running Renode locally.

üõ†Ô∏è Renode Setup Progress
1. Fixed REPL/RESC scripts for macOS

You created working copies:

stm32l552_ramn_mac.repl

ramn_mac.resc

Adjusted paths to absolute macOS paths (/Users/yusufshaikh/Desktop/...).

Corrected syntax issues (comments, quotes, line breaks).

Platform now loads and runs correctly with:

(monitor) i @/path/to/ramn_mac.resc

‚öôÔ∏è Identifying the UART Peripheral

You ran:

grep -R "HAL_UART_Init" firmware/RAMNV1/Core/Src
grep -R "huart" firmware/RAMNV1/Core


Result:

HAL_UART_Init(&hlpuart1)
if(huart->Instance==LPUART1)


‚úÖ Confirmed the firmware uses LPUART1 (Low-Power UART 1).
Base address: 0x40008000
IRQ: 70

So the Renode model must be for lpuart1, not usart1.

üß± REPL Updates

You added the following line inside your stm32l552_ramn_mac.repl:

lpuart1: UART.STM32F7_USART @ sysbus <0x40008000, +0x400> { frequency: 16000000; IRQ -> nvic@70 }


Now you can open an analyzer:

showAnalyzer sysbus.lpuart1

üß† Why No UART Output Initially

UART functions are wrapped in #ifdef ENABLE_UART inside ramn_uart.h.

In ramn_config.h, that line was commented out:

// #define ENABLE_UART


That means UART code wasn‚Äôt compiled at all ‚Üí no output.

‚úÖ Enabling UART

You uncommented that line:

#define ENABLE_UART


When you rebuilt, compilation failed with:

#error Default code does not support UART and CDC (USB Serial) at the same time.


So the project enforces mutual exclusion between the UART console and the USB-CDC (Composite USB) stack.

üîß Resolving UART vs USB Conflict

You then modified ramn_config.h to:

Keep #define ENABLE_UART

Disable USB-CDC, Composite, or GSUSB defines to avoid the conflict.

Recommended snippet:

#define ENABLE_UART

#ifdef ENABLE_UART
  #ifdef ENABLE_USB_DEVICE
    #undef ENABLE_USB_DEVICE
  #endif
  #ifdef ENABLE_USB_CDC
    #undef ENABLE_USB_CDC
  #endif
  #ifdef ENABLE_USB_COMPOSITE
    #undef ENABLE_USB_COMPOSITE
  #endif
  #ifdef ENABLE_GSUSB
    #undef ENABLE_GSUSB
  #endif
#endif


Also wrapped any MX_USB_Device_Init() in:

#ifndef ENABLE_UART
  MX_USB_Device_Init();
#endif


---

**Cursor**

I'll update your Renode scripts so the UART analyzer attaches to LPUART1 and set its clock to match the MCU (80 MHz). Then I'll confirm what else remains to get visible UART output.

```plaintext
mach create "ecu0"

machine LoadPlatformDescription @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/stm32l552_ramn_mac.repl
sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf

showAnalyzer sysbus.lpuart1
emulation CreateCANHub "canHub0"
connector Connect sysbus.fdcan1 canHub0

cpu LogFunctionNames true
start


```

I updated the load script to open the analyzer on `sysbus.lpuart1` so you'll see the correct UART in Renode. I'll quickly check for available UART send APIs so we know what function to call to actually emit text over LPUART1.

I'll scan the UART module headers and source to confirm the send API and whether anything prints by default when UART is enabled.

I‚Äôm going to set the LPUART1 peripheral clock in your platform description to 80 MHz so baud rate math matches the firmware.

```plaintext
nvic: IRQControllers.NVIC @ sysbus <0xE000E000, +0x1000>

cpu: CPU.CortexM @ sysbus
    cpuType: "cortex-m33"
    nvic: nvic


flash: Memory.MappedMemory @ sysbus 0x08000000 { size: 0x80000 }
sram1: Memory.MappedMemory @ sysbus 0x20000000 { size: 0x40000 }




lpuart1: UART.STM32F7_USART @ sysbus <0x40008000, +0x400> { frequency: 80000000; IRQ -> nvic@70 }


usart1: UART.STM32F7_USART @ sysbus <0x40013800, +0x400> { frequency: 16000000; IRQ -> nvic@37 }
usart3: UART.STM32F7_USART @ sysbus <0x40004800, +0x400> { frequency: 16000000; IRQ -> nvic@39 }


fdcan1: CAN.STMCAN @ sysbus <0x40006400, +0x400>


rcc:       Memory.MappedMemory @ sysbus 0x40021000 { size: 0x400 }
flash_if:  Memory.MappedMemory @ sysbus 0x40022000 { size: 0x400 }
tim1_stub: Memory.MappedMemory @ sysbus 0x40012C00 { size: 0x400 }
pwr:       Memory.MappedMemory @ sysbus 0x40007000 { size: 0x400 }


```

I understand. You‚Äôre emulating the RAMN firmware on Renode, need UART over LPUART1, and you‚Äôve enabled `ENABLE_UART` while avoiding conflicts with USB-CDC.

- I switched the analyzer to the right peripheral and set its clock so baud timing matches the firmware.

What I changed
- `firmware/RAMNV1/Debug/ramn_mac.resc`: analyzer now targets LPUART1.
- `firmware/RAMNV1/Debug/stm32l552_ramn_mac.repl`: `lpuart1` frequency set to 80 MHz.

How to see output
1) Rebuild with `ENABLE_UART` and with USB/CDC disabled (no `ENABLE_USB`, `ENABLE_CDC`, `ENABLE_GSUSB`).
2) Run Renode and load:
   - Monitor: `i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc`
3) UART should print every ~1s via the customization hook:

```92:95:firmware/RAMNV1/Core/Src/ramn_customize.c
#ifdef ENABLE_UART
		RAMN_UART_SendStringFromTask("Hello from RAMN\r");
#endif
```

If you still see nothing or gibberish
- Ensure your build actually defined `ENABLE_UART` (and not CDC) and that `HAL_UART_Receive_IT` path compiled (it does under `#elif defined(ENABLE_UART)` in `main.c`).
- Analyzer is on `sysbus.lpuart1`; with the 80 MHz setting it should match the HAL config for 115200.

- Updated `ramn_mac.resc` to use `showAnalyzer sysbus.lpuart1` and set `lpuart1` frequency in the `.repl` to 80 MHz so your LPUART1 output (‚ÄúHello from RAMN‚Äù) appears in Renode.

```c
#ifdef ENABLE_UART
		RAMN_UART_SendStringFromTask("Hello from RAMN\r");
#endif
```

---

**User**

22:19:40 **** Incremental Build of configuration Debug for project RAMNV1 ****
make -j7 all 
arm-none-eabi-gcc "../USB_CompositeDevice/Target/usbd_conf.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"USB_CompositeDevice/Target/usbd_conf.d" -MT"USB_CompositeDevice/Target/usbd_conf.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "USB_CompositeDevice/Target/usbd_conf.o"
arm-none-eabi-gcc "../USB_CompositeDevice/App/usb_device.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"USB_CompositeDevice/App/usb_device.d" -MT"USB_CompositeDevice/App/usb_device.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "USB_CompositeDevice/App/usb_device.o"
arm-none-eabi-gcc "../USB_CompositeDevice/App/usbd_cdc_if.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"USB_CompositeDevice/App/usbd_cdc_if.d" -MT"USB_CompositeDevice/App/usbd_cdc_if.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "USB_CompositeDevice/App/usbd_cdc_if.o"
arm-none-eabi-gcc "../USB_CompositeDevice/App/usbd_desc.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"USB_CompositeDevice/App/usbd_desc.d" -MT"USB_CompositeDevice/App/usbd_desc.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "USB_CompositeDevice/App/usbd_desc.o"
arm-none-eabi-gcc "../USB_CompositeDevice/App/usbd_gsusb_if.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"USB_CompositeDevice/App/usbd_gsusb_if.d" -MT"USB_CompositeDevice/App/usbd_gsusb_if.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "USB_CompositeDevice/App/usbd_gsusb_if.o"
arm-none-eabi-gcc "../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_core.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_core.d" -MT"Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_core.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_core.o"
arm-none-eabi-gcc "../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_ctlreq.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_ctlreq.d" -MT"Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_ctlreq.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_ctlreq.o"
In file included from ../USB_CompositeDevice/App/usbd_cdc_if.c:25:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
../USB_CompositeDevice/App/usbd_cdc_if.c:433: warning: ISO C forbids an empty translation unit [-Wpedantic]
make: *** [USB_CompositeDevice/App/subdir.mk:28: USB_CompositeDevice/App/usbd_cdc_if.o] Error 1
make: *** Waiting for unfinished jobs....
In file included from ../Core/Inc/main.h:37,
                 from ../Core/Inc/ramn_utils.h:22,
                 from ../USB_CompositeDevice/App/usbd_gsusb_if.c:20:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
In file included from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/../../../../../USB_CompositeDevice/Target/usbd_conf.h:36,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/usbd_def.h:29,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/usbd_composite.h:27,
                 from ../USB_CompositeDevice/App/usbd_gsusb_if.h:28,
                 from ../USB_CompositeDevice/App/usb_device.c:25:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
In file included from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/../../USBCore/Inc/../../../../../USB_CompositeDevice/Target/usbd_conf.h:36,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/../../USBCore/Inc/usbd_core.h:29,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_core.c:21:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
In file included from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/../../USBCore/Inc/../../USBCore/Inc/../../../../../USB_CompositeDevice/Target/usbd_conf.h:36,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/../../USBCore/Inc/../../USBCore/Inc/usbd_def.h:29,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/../../USBCore/Inc/usbd_ctlreq.h:29,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_ctlreq.c:21:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
In file included from ../USB_CompositeDevice/App/../../USB_CompositeDevice/App/../../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/../../../../../USB_CompositeDevice/Target/usbd_conf.h:36,
                 from ../USB_CompositeDevice/App/../../USB_CompositeDevice/App/../../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/usbd_def.h:29,
                 from ../USB_CompositeDevice/App/../../USB_CompositeDevice/App/usbd_desc.h:31,
                 from ../USB_CompositeDevice/App/usbd_desc.c:23:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
make: *** [USB_CompositeDevice/App/subdir.mk:28: USB_CompositeDevice/App/usbd_desc.o] Error 1
In file included from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/../../../../../USB_CompositeDevice/Target/usbd_conf.h:36,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/usbd_core.h:29,
                 from ../USB_CompositeDevice/Target/usbd_conf.c:25:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
In file included from ../Core/Inc/main.h:37,
                 from ../USB_CompositeDevice/App/usb_device.c:28:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
In file included from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/../../../../../USB_CompositeDevice/Target/usbd_conf.h:36,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc/usbd_def.h:29,
                 from ../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/usbd_composite.h:27,
                 from ../USB_CompositeDevice/App/usbd_gsusb_if.h:28,
                 from ../USB_CompositeDevice/App/usbd_gsusb_if.c:21:
../Core/Inc/ramn_config.h:453:2: error: #endif without #if
  453 | #endif /* INC_RAMN_CONFIG_H_ */
      |  ^~~~~
make: *** [Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/subdir.mk:25: Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_core.o] Error 1
make: *** [USB_CompositeDevice/App/subdir.mk:28: USB_CompositeDevice/App/usb_device.o] Error 1
make: *** [Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/subdir.mk:25: Middlewares/ST/STM32_USB_Device_Library/USBCore/Src/usbd_ctlreq.o] Error 1
make: *** [USB_CompositeDevice/App/subdir.mk:28: USB_CompositeDevice/App/usbd_gsusb_if.o] Error 1
make: *** [USB_CompositeDevice/Target/subdir.mk:19: USB_CompositeDevice/Target/usbd_conf.o] Error 1
"make -j7 all" terminated with exit code 2. Build might be incomplete.

22:19:41 Build Failed. 17 errors, 1 warnings. (took 847ms)

---

**Cursor**

I'll fix the preprocessor mismatch in `ramn_config.h` (a commented-out `#ifndef` left a live `#else/#endif`), then you can rebuild.

I'll fix the stray preprocessor directives in `ramn_config.h` by commenting out the unmatched `#else/#endif` around the GSUSB VID/PID block, then you can rebuild.

```cpp
/*
 * ramn_config.h
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 * This software component is licensed by TOYOTA MOTOR CORPORATION under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

// This module holds the configuration of current build.

#ifndef INC_RAMN_CONFIG_H_
#define INC_RAMN_CONFIG_H_

#if !defined(TARGET_ECUA) && !defined(TARGET_ECUB) && !defined(TARGET_ECUC) && !defined(TARGET_ECUD)
// Define which ECU the source code should be built for.
// You need to specify which ECU you are trying to debug here.
// This define is only used for debugging - the build scripts in scripts/build will override this define.
#define TARGET_ECUA
// #define TARGET_ECUB
// #define TARGET_ECUC
// #define TARGET_ECUD
#endif

// See comments at the end of file if you want to use the internal oscillator instead of the external crystal.

// Enable the flag below if you want to disable features that may impact security (e.g., ReadMemoryByAddress UDS service, etc.).
// This can be used to put RAMN in a state ready to be customized for Capture The Flag applications.
// By default, this will generate compile errors that you will need to address by removing relevant defines or commenting out the #error lines.
// Note that the USB CLI will be active but not accessible unless you make the "#" command available again (by editing ramn_cdc.c).
// UDS over USB (slcan command "%" is accessible by default, but you may want to remove it (also by editing ramn_cdc.c) to further limit attack surfaces.
// #define HARDENING

// CONFIGURATION OF ECU A ------------------------------------------------------

#if defined(TARGET_ECUA)
// #define ENABLE_ADC
// #define ENABLE_USB
// #define ENABLE_CDC // USB serial (CDC) interface

// Enable this flag to enable the candlelight interface (gs_usb drivers)
// Current implementation is experimental:
// - Error frames are not reported
// - CAN-FD is not supported
// - Due to clock differences, bit timings are not respected (but equivalent baudrates are used)
// Try increasing _Min_Stack_Size if you run into issues
// #define ENABLE_GSUSB

// #ifndef ENABLE_GSUSB
// #define USBD_VID 0x483
// #define USBD_PID 0x5740
// #else
// IDs below automatically load the drivers on Linux and are required for userspace python-can drivers
#define USBD_VID 0x1d50
#define USBD_PID 0x606f
// #endif

#define USBD_LANGID_STRING 1033
#define USBD_MANUFACTURER_STRING "Toyota Motor Corporation"
#define USBD_PRODUCT_STRING "RAMN USB Composite Device"
#define USBD_CONFIGURATION_STRING "MDC Config"
#define USBD_INTERFACE_STRING "MDC Interface"

// Enable SPI (for screen control)
#define ENABLE_SPI

// Enable screen (not restricted to ECU A).
#define ENABLE_SCREEN

// Enable Chip 8 engine.
#define ENABLE_CHIP8

// Enable USB MiniCTF challenges.
#define ENABLE_MINICTF

// Note that UDS programming does not work on microcontrollers with only 256 kb memory (e.g., reference ending with CCT6).
#define ENABLE_UDS_REPROGRAMMING
#define ENABLE_UDS
#define ENABLE_J1979
// #define ENABLE_KWP
// #define ENABLE_XCP
#define RTR_DEMO_ID 0x700

// ECU will monitor joystick CAN messages and generate events such as PRESSED and RELEASED.
// You must independently make sure that the ECU does not filter out the relevant CAN messages (which it shouldn't by default).
#define ENABLE_JOYSTICK_CONTROLS

// Use this to define a "password" for the command to put ECU A back into DFU mode.
// Note that this is not for security (because STM32 can be put back into DFU mode over JTAG, and if JTAG is permanently disabled (level 2) the back-to-DFU command won't work correctly anyway).
// This is only to prevent users from accidentally putting the ECU back into DFU mode (e.g. because of fuzzing).
#define DFU_COMMAND_STRING "zZ"

// Automatically close the serial port if it overflows (consider that the user forgot to close it).
#define CLOSE_DEVICE_ON_USB_TX_OVERFLOW

// Automatically stops transmitting when serial port close is detected.
// May not work well with some OS/Applications
// #define ENABLE_USB_AUTODETECT

// Will start the usb serial interface in CLI mode instead of slcan if enabled.
// If used with HARDENING, make sure you make the "#" slcan command available again.
// #define START_IN_CLI_MODE

// Define this flag to let ECU A process slcan message that it receives as regular RX messages (and update their value on screen, for example).
// This is useful to demonstrate the impact of CAN fuzzing on ECU A's screen when using ECU A's slcan interface, even though ECU A did not actually receive the fuzzed CAN message (since it was the transmitter).
#define PROCESS_SLCAN_BY_DBC

// Define this flag to enable the USB debugging module.
// Note that it also needs to be activated by a slcan command, or by setting RAMN_DEBUG_ENABLE in ramn_debug.c to True.
// #define ENABLE_USB_DEBUG

// Number of times to retry entering bootloader mode of another ECU before giving up
#define BOOTLOADER_MAX_ATTEMPTS 20

#ifdef ENABLE_GSUSB
#define GSUSB_RECV_QUEUE_SIZE 512 // Size of the GSUSB receive queue (uint32_t elements)
#define GSUSB_POOL_QUEUE_SIZE 512 // Size of the GSUSB pool queue (uint32_t elements)
#define GSUSB_SEND_QUEUE_SIZE 512 // Size of the GSUSB send queue (uint32_t elements)
#define GS_HOST_FRAME_SIZE 80
#define CAN_QUEUE_SIZE 512
#endif
#define GSUSB_DFU_INTERFACE_STRING_FS (uint8_t *)"RAMN gs_usb interface"

#endif

// CONFIGURATION OF ECU B ------------------------------------------------------

#if defined(TARGET_ECUB)
// #define ENABLE_SCREEN
#define ENABLE_ADC
#define EXPANSION_CHASSIS

// Define flag below to indicate that the steering wheel potentiometer is of the logarithmic type.
// #define CHASSIS_LOGARITHMIC_POTENTIOMETER
#if !defined(CHASSIS_LOGARITHMIC_POTENTIOMETER) && !defined(CHASSIS_LINEAR_POTENTIOMETER)
// If CHASSIS_LINEAR_POTENTIOMETER not defined by build script, consider Log as default
#define CHASSIS_LOGARITHMIC_POTENTIOMETER
#endif

#define ENABLE_UDS_REPROGRAMMING
#define ENABLE_UDS
#define ENABLE_J1979
// #define ENABLE_KWP
#define ENABLE_XCP
#define RTR_DEMO_ID 0x701
#endif

// CONFIGURATION OF ECU C ------------------------------------------------------

#if defined(TARGET_ECUC)
// #define ENABLE_SCREEN
#define ENABLE_ADC
#define EXPANSION_POWERTRAIN
#define ENABLE_UDS_REPROGRAMMING
#define ENABLE_UDS
#define ENABLE_J1979
// #define ENABLE_KWP
#define ENABLE_XCP
#define RTR_DEMO_ID 0x702
#endif

// CONFIGURATION OF ECU D ------------------------------------------------------

#if defined(TARGET_ECUD)
#define ENABLE_MINICTF
#define ENABLE_ADC
#define EXPANSION_BODY

// Enable SPI (for LED control)
#define ENABLE_SPI

#define ENABLE_UDS_REPROGRAMMING
#define ENABLE_UDS
#define ENABLE_J1979
// #define ENABLE_KWP
#define ENABLE_XCP
#define RTR_DEMO_ID 0x703

// How long to light up ECU D's LEDs at startup. Set to 0 to skip test.
#define LED_TEST_DURATION_MS 3000U
#endif

// Common configuration ------------------------------------------------------

// Loop time for the "simulator" that is executed periodically.
#define SIM_LOOP_CLOCK_MS 10

// Enable watchdogs - Application needs to kick it every 1s.
// #define WATCHDOG_ENABLE

// Will make ECU accept broadcasted UDS commands.
// CAN ID must be defined in ramn_vehicle_specific.h.
#define UDS_ACCEPT_FUNCTIONAL_ADDRESSING

// Enable dynamic computations of tseg1 and tseg2 to get non-standard baudrate.
// If you change the clock of the FDCAN peripheral, you'll need to update this too.
// /!\CURRENTLY UNTESTED
#define ENABLE_DYNAMIC_BITRATE
#define FDCAN_PERIPHERAL_CLOCK 40000000

// Enable this flag to enable FreeRTOS runtime stats.
// This also requires to add "volatile" keyword to static uint32_t ulTotalRunTime = 0UL in tasks.c of FreeRTOS (typically overwritten by STM32CubeIDE code generation).
// Increase the frequency of runtime timer (by default, TIM7) to increase stat accuracy at the cost of performances.
#define GENERATE_RUNTIME_STATS
#define MAX_NUMBER_OF_TASKS 16 // Max number of tasks that can be monitored, if enabled
// If this flag is enabled, ECU A will repeat whatever message it accepts over USB.
// May be useful when multiplexing the serial interface, but should typically not be used.
// CAN_ECHO does not cover ECU A CAN messages not sent from USB (i.e., answer to UDS commands).
// #define CAN_ECHO

// This flag can be used to automatically reset CAN/CAN-FD peripheral if it enters bus-off mode.
// #define AUTO_RECOVER_BUSOFF

// Use big endian for CAN brake/steering/accelerator sensors instead of ARM Little Endian.
#define USE_BIG_ENDIAN_CAN

#ifndef TARGET_ECUA
// Use Hardware CAN filters (Up to 28 standard IDs, 8 extended IDs).
// If this is enabled, you need to update ECU RX filters when you want to add CAN IDs to the network.
#define USE_HARDWARE_CAN_FILTERS
#endif

// Enable these flags to display a warning if the periodic task is taking longer than the defined period.
// #define DISPLAY_SLOW_WARNING

// If the flag above is defined, you can decide to skip the first cycles, which are expected to take longer due to initializations.
#define SLOW_WARNING_MIN_LOOP_COUNT 1U

// Enable the I2C interface
// /!\CURRENTLY UNTESTED
// #define ENABLE_I2C

// Enable the UART interface
// /!\ CURRENTLY UNTESTED
#define ENABLE_UART

// Enable this flag to force code to while(1) when encountering errors that could typically be ignored.
// #define HANG_ON_ERRORS

// Enable this flag to automatically enable memory protection at startup. Once activated, it can only be removed by bootloader/usb commands.
// Avoid using if you are not sure what you are doing.
// #define MEMORY_AUTOLOCK

// Value to set to the RDP option byte if flag above is active.
// It is 0xAA when unlocked (OB_RDP_LEVEL_0), 0xBB if temporarily locked by bootloader (OB_RDP_LEVEL_1, or 0xDC if locked by STM32CubeProgrammer).
// Setting this value to 0xCC (OB_RDP_LEVEL_2) will PERMANENTLY LOCK JTAG (the ECU will not be reprogrammable anymore)
#define RDP_OPTIONBYTE OB_RDP_LEVEL_1

// If this is defined, the TRNG module will fill a stream buffer with random bytes instead of calling the HAL library.
// #define USE_TRNG_BUFFER

// TRNG pool settings (if used)
#define TRNG_POOL_SIZE 256
#define JOYSTICK_POOL_SIZE 10

#ifdef ENABLE_I2C
#define I2C_RX_BUFFER_SIZE (16)
#define I2C_TX_BUFFER_SIZE (4)
#endif

#ifdef ENABLE_UART

// UART module works by queuing commands in a stream buffer.
// You should define the size of working buffers (for currently processed command/answers) and of stream buffers (where all commands/queued are queued and waiting for transmission).

// Working buffer
#define UART_RX_COMMAND_BUFFER_SIZE 128 // This is the maximum length of a command to receive, used by both TASK and ISR
#define UART_TX_COMMAND_BUFFER_SIZE 128 // This is the maximum length of a command to send back

// Stream buffer
#define UART_RX_BUFFER_SIZE 512
#define UART_TX_BUFFER_SIZE 512

#if (UART_RX_COMMAND_BUFFER_SIZE > UART_RX_BUFFER_SIZE) || (UART_TX_COMMAND_BUFFER_SIZE > UART_TX_BUFFER_SIZE)
#error command size should be smaller than stream buffer size
#endif

#endif

#if defined(ENABLE_UDS) || defined(ENABLE_KWP) || defined(ENABLE_XCP)
#define ENABLE_DIAG
#define ENABLE_EEPROM_EMULATION
#if defined(ENABLE_SCREEN)
// Size of the buffer used to draw on screen using UDS commands
#define UDS_DRAW_BUFFER_SIZE 0x1000
#endif
#endif

#if defined(ENABLE_UDS) || defined(ENABLE_KWP)
#define ENABLE_ISOTP
#endif

#define ISOTP_RXBUFFER_SIZE 4096
#define ISOTP_TXBUFFER_SIZE 4096
#define ISOTP_CONSECUTIVE_BLOCK_SIZE 0
#define ISOTP_CONSECUTIVE_ST 0

// ISO-TP Timeout values. Both should be set to 1000 to mimic real ECUs.
#define ISOTP_RX_TIMEOUT_MS 200000
#define ISOTP_TX_TIMEOUT_MS 200000

// Timeout for extended diagnostic session.
// By default, other session types do not time out, although they would on real ECUs.
#define UDS_SESSION_TIMEOUT_MS 5000

// Maximum RPM that will allow a transition to diagnostic sessions.
// Can be used to emulate a "Conditions not correct" error when the vehicle is running in Carla.
#define UDS_MAXIMUM_RPM_ACCEPTABLE 0xFFF

// Delay before accepting a new security access attempt.
// This delay also applies to minimum time between ECU boot and first attempt.
#define SECURITY_ACCESS_RETRY_TIMEOUT_MS 10

// Maximum Security access attempts before locking device.
#define SECURITY_ACCESS_MAX_ATTEMPTS 5

// Enable this flag to ignore ISO TP messages that are not padded (like real ECUs do).
// When this flag is enabled, the ECU only checks that ISO-TP CAN message size is 8, it does not check the value of the padding bytes.
// This only applies to requests - see flag below for answers.
// #define ISOTP_REQUIRE_PADDING

// Define this flag to make the ECU pad its ISO-TP answers with the defined byte (until ISO-TP CAN messages reach a size of 8).
// This only applies to answers - see flag above for requests.
// #define ISOTP_ANSWER_PADDING_BYTE 0x00

#ifdef ENABLE_CDC
#define APP_RX_DATA_SIZE 2048
#define APP_TX_DATA_SIZE 2048
#define USB_COMMAND_BUFFER_SIZE (8195)
#endif

#ifdef TARGET_ECUA
#define USB_RX_BUFFER_SIZE 15000
#define USB_TX_BUFFER_SIZE 15000
#define CAN_RX_BUFFER_SIZE 15000
#define CAN_TX_BUFFER_SIZE 15000
#define UDS_ISOTP_RX_BUFFER_SIZE 0xFFF + 2 // Add +2 for buffer-size
#define UDS_ISOTP_TX_BUFFER_SIZE 0xFFF + 2

#else
#define CAN_RX_BUFFER_SIZE 20480
#define CAN_TX_BUFFER_SIZE 20480
#define UDS_ISOTP_RX_BUFFER_SIZE (4097 * 6)
#define UDS_ISOTP_TX_BUFFER_SIZE (4097 * 6)
#define KWP_ISOTP_RX_BUFFER_SIZE (4097 * 6)
#define KWP_ISOTP_TX_BUFFER_SIZE (4097 * 6)
#define XCP_RX_BUFFER_SIZE (4000)
#define XCP_TX_BUFFER_SIZE (4000)
#endif

// This Extended ID is set as a hardware filter example event when CTF is disabled.
#define CTF_EXTENDED_ID 0x77cafe
#ifdef ENABLE_MINICTF
#define CTF_STANDARD_ID_1 0x456
#define CTF_STANDARD_ID_2 0x772
#define CTF_STANDARD_ID_3 0x457
#define CTF_STANDARD_ID_4 0x458
#endif

// Check for bad configurations --------------------------------------

#ifdef ENABLE_CDC
#if USB_RX_BUFFER_SIZE < (USB_COMMAND_BUFFER_SIZE + 2)
#error define a larger USB_RX_BUFFER_SIZE
#endif
#endif

#if defined(TARGET_ECUA) + defined(TARGET_ECUB) + defined(TARGET_ECUC) + defined(TARGET_ECUD) != 1
#error "You must define only one of TARGET_ECUA, TARGET_ECUB, TARGET_ECUC, and TARGET_ECUD."
#endif

#if defined(ENABLE_UART) && defined(ENABLE_CDC)
#error Default code does not support UART and CDC (USB Serial) at the same time. See comments for details.
// UART uses CDC task by default, and therefore CDC and UART cannot be used at the same time.
// You can enable both simultaneously by creating new receive/transmit tasks for UART, and move the UART code (between #define ENABLE_UART) in RAMN_ReceiveUSBFunc and RAMN_SendUSBFunc there.
// You should then modify HAL_UART_TxCpltCallback and HAL_UART_RxCpltCallback to notify these tasks instead.
#endif

#if defined(ENABLE_CHIP8) && !defined(ENABLE_SCREEN)
#error ENABLE_SCREEN must be defined to define ENABLE_CHIP8
#endif

#if !defined(ENABLE_USB) && defined(ENABLE_CDC)
#error Cannot activate CDC without enabling USB
#endif

#if !defined(ENABLE_USB) && defined(ENABLE_GSUSB)
#error Cannot activate GSUSB without enabling USB
#endif

#if defined(ENABLE_USB) && !defined(ENABLE_CDC) && !defined(ENABLE_GSUSB)
#error At least one USB interface must be active if you enable USB
#endif

#ifdef HARDENING
#ifdef ENABLE_GSUSB
#error "It is preferable to turn off GS_USB to limit attack surfaces. Comment out this line to enable anyway."
#endif
#ifdef ENABLE_KWP
#error "It is preferable to turn off KWP2000 to limit attack surfaces. Comment out this line to enable anyway."
#endif
#ifdef ENABLE_XCP
#error "It is preferable to turn off XCP to limit attack surfaces. Comment out this line to enable anyway (You'll need to update RAMN_MEMORY_CheckAreaReadable and/or XCP_COMMAND_UPLOAD)."
#endif
#ifdef ENABLE_J1979
#error "It is preferable to turn off J1979 to limit attack surfaces. Comment out this line to enable anyway"
#endif
#ifdef ENABLE_USB_DEBUG
#error "It is preferable to turn off USB debug to limit attack surfaces. Comment out this line to enable anyway."
#endif
#ifdef ENABLE_CHIP8
#error "It is preferable to turn off CHIP8 engine to limit attack surfaces. Comment out this line to enable anyway."
#endif
#ifdef ENABLE_MINICTF
#error "You may want to disable the mini-ctf to avoid conflicts. Comment out this line to enable anyway."
#endif
#ifdef ENABLE_UDS_REPROGRAMMING
#error "You may want to disable reprogramming to avoid accidental firmware erasure. Comment out this line to enable anyway."
#endif
#ifdef GENERATE_RUNTIME_STATS
#error "You may want to disable runtime stats to limit accessible information. Comment out this line to enable anyway."
#endif
#ifdef ENABLE_EEPROM_EMULATION
#error "You may want to disable EEPROM to limit potential memory issues. Comment out this line to enable anyway."
#endif
#endif

// To use the internal oscillator (instead of the default external 10MHz crystal), You should modify RAMNV1.ioc so that:
// - PLL Source Mux uses HSI with *N = X 10
// - PLLSAI1 Source Mux uses HSI with *N = X 15
// You should then regenerate the source code (refer to docs/firmware/img/internal_clock_settings.png and external_clock_settings.png to compare clock settings).
// If you do not want to use the code generation feature,you can also modify the source code directly so that the following values are used instead of default values:
//
// In stm32l5xx_hal_msp.c:
// PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSAI1SOURCE_HSI;
// PeriphClkInit.PLLSAI1.PLLSAI1N = 15;
//
// In main.c:
//
// RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
// RCC_OscInitStruct.HSIState = RCC_HSI_ON;
// RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
// RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
// RCC_OscInitStruct.PLL.PLLN = 10;

#endif /* INC_RAMN_CONFIG_H_ */

```

- I commented out the unmatched `#else/#endif` in `ramn_config.h` near the GSUSB VID/PID block to resolve the ‚Äú#endif without #if‚Äù errors. Rebuild now.

- If you still see USB files compiling: disable USB in `ramn_config.h` for your target (ensure `ENABLE_USB` and `ENABLE_CDC` are not defined), or exclude the `USB_CompositeDevice` group from the Debug build config.

---

**User**

it built correctly, how do i test

---

**Cursor**

### Run it in Renode and watch UART

- Start Renode, then in the Monitor run:
  ```
  i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  ```
  This loads the platform, your `RAMNV1.elf`, opens the LPUART1 analyzer, and starts the CPU.

- You should see a line about every second:
```92:95:firmware/RAMNV1/Core/Src/ramn_customize.c
#ifdef ENABLE_UART
		RAMN_UART_SendStringFromTask("Hello from RAMN\r");
#endif
```

### If you don‚Äôt see text
- Open the analyzer manually:
  ```
  showAnalyzer sysbus.lpuart1
  ```
- Ensure your build still has `ENABLE_UART` enabled and USB/CDC disabled in `ramn_config.h`.
- Confirm the script points to the correct ELF path in `ramn_mac.resc` line 4.

### Optional: send input to UART
- In the UART analyzer, type a line and press Enter to send a command (it‚Äôs processed on carriage return).

```plaintext
  i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  ```
  This loads the platform, your `RAMNV1.elf`, opens the LPUART1 analyzer, and starts the CPU.

- You should see a line about every second:
```92:95:firmware/RAMNV1/Core/Src/ramn_customize.c
#ifdef ENABLE_UART
		RAMN_UART_SendStringFromTask("Hello from RAMN\r");
#endif
```

### If you don‚Äôt see text
- Open the analyzer manually:
  ```
  showAnalyzer sysbus.lpuart1
  ```
- Ensure your build still has `ENABLE_UART` enabled and USB/CDC disabled in `ramn_config.h`.
- Confirm the script points to the correct ELF path in `ramn_mac.resc` line 4.

### Optional: send input to UART
- In the UART analyzer, type a line and press Enter to send a command (it‚Äôs processed on carriage return).
```

```c
#ifdef ENABLE_UART
		RAMN_UART_SendStringFromTask("Hello from RAMN\r");
#endif
```

```plaintext
  showAnalyzer sysbus.lpuart1
```

---

**User**

the lpuart1 opened but it doesnt say anything. the renode term shows this, and then justa bunch of "Entering function Error_Handler at"

---

**Cursor**

Let me add a minimal Renode-only path that initializes only LPUART1 and prints a heartbeat, bypassing the failing clock/peripheral init. Then you can rerun in Renode to verify UART output.

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
  .name = "RAMN_ReceiveUSB",
  .priority = (osPriority_t) osPriorityNormal,
  .stack_size = 256 * 4
};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[ 256 ];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
  .name = "RAMN_ReceiveCAN",
  .stack_mem = &RAMN_ReceiveCANBuffer[0],
  .stack_size = sizeof(RAMN_ReceiveCANBuffer),
  .cb_mem = &RAMN_ReceiveCANControlBlock,
  .cb_size = sizeof(RAMN_ReceiveCANControlBlock),
  .priority = (osPriority_t) osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[ 256 ];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
  .name = "RAMN_SendCAN",
  .stack_mem = &RAMN_SendCANBuffer[0],
  .stack_size = sizeof(RAMN_SendCANBuffer),
  .cb_mem = &RAMN_SendCANControlBlock,
  .cb_size = sizeof(RAMN_SendCANControlBlock),
  .priority = (osPriority_t) osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[ 256 ];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
  .name = "RAMN_Periodic",
  .stack_mem = &RAMN_PeriodicBuffer[0],
  .stack_size = sizeof(RAMN_PeriodicBuffer),
  .cb_mem = &RAMN_PeriodicControlBlock,
  .cb_size = sizeof(RAMN_PeriodicControlBlock),
  .priority = (osPriority_t) osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[ 256 ];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
  .name = "RAMN_ErrorTask",
  .stack_mem = &RAMN_ErrorTaskBuffer[0],
  .stack_size = sizeof(RAMN_ErrorTaskBuffer),
  .cb_mem = &RAMN_ErrorTaskControlBlock,
  .cb_size = sizeof(RAMN_ErrorTaskControlBlock),
  .priority = (osPriority_t) osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[ 256 ];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
  .name = "RAMN_DiagRX",
  .stack_mem = &RAMN_DiagRXBuffer[0],
  .stack_size = sizeof(RAMN_DiagRXBuffer),
  .cb_mem = &RAMN_DiagRXControlBlock,
  .cb_size = sizeof(RAMN_DiagRXControlBlock),
  .priority = (osPriority_t) osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[ 256 ];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
  .name = "RAMN_DiagTX",
  .stack_mem = &RAMN_DiagTXBuffer[0],
  .stack_size = sizeof(RAMN_DiagTXBuffer),
  .cb_mem = &RAMN_DiagTXControlBlock,
  .cb_size = sizeof(RAMN_DiagTXControlBlock),
  .priority = (osPriority_t) osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
  .name = "RAMN_SendUSB",
  .priority = (osPriority_t) osPriorityRealtime,
  .stack_size = 256 * 4
};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
  .name = "RAMN_RxTask2",
  .priority = (osPriority_t) osPriorityHigh1,
  .stack_size = 512 * 4
};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
  .name = "RAMN_TxTask2",
  .priority = (osPriority_t) osPriorityHigh2,
  .stack_size = 256 * 4
};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__ ((section (".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[ GSUSB_RECV_QUEUE_SIZE * sizeof( uint32_t ) ];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
		.name = "RAMN_GSUSB_RecvQueue",
		.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
		.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
		.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
		.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)
};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__ ((section (".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[ GSUSB_POOL_QUEUE_SIZE * sizeof( uint32_t ) ];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
		.name = "RAMN_GSUSB_PoolQueue",
		.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
		.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
		.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
		.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)
};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__ ((section (".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[ GSUSB_SEND_QUEUE_SIZE * sizeof( uint32_t ) ];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
		.name = "RAMN_GSUSB_SendQueue",
		.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
		.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
		.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
		.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)
};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__ ((section (".buffers")))  uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__ ((section (".buffers")))  uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__ ((section (".buffers")))  uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__ ((section (".buffers"))) static uint8_t  UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__ ((section (".buffers")))  uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__ ((section (".buffers")))  uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__ ((section (".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__ ((section (".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__ ((section (".buffers"), aligned(4)))  uint8_t diagRxbuf[0xFFF+2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__ ((section (".buffers")))  uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__ ((section (".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__ ((section (".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__ ((section (".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__ ((section (".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__ ((section (".buffers")))  static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void) {
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void) {
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Minimal Renode path: initialize only UART and print periodically
	MX_LPUART1_UART_Init();
	const uint8_t msg[] = "Hello from RAMN\r";
	for(;;)
	{
		HAL_UART_Transmit(&hlpuart1, (uint8_t*)msg, sizeof(msg)-1, 0xFFFF);
		// crude delay loop (~1s depending on Renode speed)
		for(volatile uint32_t d=0; d<800000; ++d) {}
	}
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if(RAMN_FLASH_isMemoryProtected() == False) RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_DMA_Init();
  MX_ICACHE_Init();
  MX_RNG_Init();
  MX_FDCAN1_Init();
  MX_SPI2_Init();
  MX_ADC1_Init();
  MX_IWDG_Init();
  MX_CRC_Init();
  MX_I2C2_Init();
  MX_LPUART1_UART_Init();
  MX_USB_PCD_Init();
  MX_TIM7_Init();
  MX_TIM6_Init();
  MX_TIM16_Init();
  /* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle   = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE,sizeof(uint8_t),USB_RX_BUFFER,&USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle   = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE,sizeof(uint8_t),USB_TX_BUFFER,&USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle   = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE,sizeof(uint8_t),UART_RX_BUFFER,&UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle   = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE,sizeof(uint8_t),UART_TX_BUFFER,&UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE,sizeof(uint8_t),UDS_ISOTP_RX_BUFFER,&UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE,sizeof(uint8_t),UDS_ISOTP_TX_BUFFER,&UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE,sizeof(uint8_t),KWP_ISOTP_RX_BUFFER,&KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE,sizeof(uint8_t),KWP_ISOTP_TX_BUFFER,&KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE,sizeof(uint8_t),XCP_RX_BUFFER,&XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE,sizeof(uint8_t),XCP_TX_BUFFER,&XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE,sizeof(uint8_t),CAN_RX_BUFFER,&CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE,sizeof(uint8_t),CAN_TX_BUFFER,&CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) //if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(),&RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1,&RAMN_SendCANHandle,&RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16; // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30;// "01" for chassis ("C")
			dtcVal |= 0x0563 << 16; // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30;// "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16; // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30;// "10" for body ("B")
			dtcVal |= 0x0091 << 16; // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; //mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();

  /* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* USER CODE BEGIN RTOS_SEMAPHORES */

  /* USER CODE END RTOS_SEMAPHORES */

  /* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
  /* USER CODE END RTOS_TIMERS */

  /* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew (GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew (GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew (GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of RAMN_ReceiveUSB */
  RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

  /* creation of RAMN_ReceiveCAN */
  RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

  /* creation of RAMN_SendCAN */
  RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

  /* creation of RAMN_Periodic */
  RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

  /* creation of RAMN_ErrorTask */
  RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

  /* creation of RAMN_DiagRX */
  RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

  /* creation of RAMN_DiagTX */
  RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

  /* creation of RAMN_SendUSB */
  RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

  /* creation of RAMN_RxTask2 */
  RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

  /* creation of RAMN_TxTask2 */
  RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

  /* USER CODE BEGIN RTOS_THREADS */

  /* USER CODE END RTOS_THREADS */

  /* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
  /* USER CODE END RTOS_EVENTS */

  /* Start scheduler */
  osKernelStart();

  /* We should never get here as control is now taken by the scheduler */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
	while (1)
	{
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	}
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_LSI
                              |RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 16;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
  {
    Error_Handler();
  }

  /** Enable the SYSCFG APB clock
  */
  __HAL_RCC_CRS_CLK_ENABLE();

  /** Configures CRS
  */
  RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
  RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
  RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
  RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000,1000);
  RCC_CRSInitStruct.ErrorLimitValue = 34;
  RCC_CRSInitStruct.HSI48CalibrationValue = 32;

  HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
  /* USER CODE END ADC1_Init 0 */

  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.NbrOfConversion = 3;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.DMAContinuousRequests = ENABLE;
  hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
  hadc1.Init.OversamplingMode = DISABLE;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure the ADC multi-mode
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_6;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_9;
  sConfig.Rank = ADC_REGULAR_RANK_2;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_10;
  sConfig.Rank = ADC_REGULAR_RANK_3;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */
#endif
  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{

  /* USER CODE BEGIN CRC_Init 0 */

  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}

/**
  * @brief FDCAN1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_FDCAN1_Init(void)
{

  /* USER CODE BEGIN FDCAN1_Init 0 */

  /* USER CODE END FDCAN1_Init 0 */

  /* USER CODE BEGIN FDCAN1_Init 1 */

  /* USER CODE END FDCAN1_Init 1 */
  hfdcan1.Instance = FDCAN1;
  hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
  hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
  hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
  hfdcan1.Init.AutoRetransmission = ENABLE;
  hfdcan1.Init.TransmitPause = DISABLE;
  hfdcan1.Init.ProtocolException = DISABLE;
  hfdcan1.Init.NominalPrescaler = 1;
  hfdcan1.Init.NominalSyncJumpWidth = 16;
  hfdcan1.Init.NominalTimeSeg1 = 60;
  hfdcan1.Init.NominalTimeSeg2 = 19;
  hfdcan1.Init.DataPrescaler = 1;
  hfdcan1.Init.DataSyncJumpWidth = 16;
  hfdcan1.Init.DataTimeSeg1 = 15;
  hfdcan1.Init.DataTimeSeg2 = 4;
  hfdcan1.Init.StdFiltersNbr = 1;
  hfdcan1.Init.ExtFiltersNbr = 1;
  hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
  if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN FDCAN1_Init 2 */

  /* USER CODE END FDCAN1_Init 2 */

}

/**
  * @brief I2C2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C2_Init(void)
{

  /* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
  /* USER CODE END I2C2_Init 0 */

  /* USER CODE BEGIN I2C2_Init 1 */

  /* USER CODE END I2C2_Init 1 */
  hi2c2.Instance = I2C2;
  hi2c2.Init.Timing = 0x10D19CE4;
  hi2c2.Init.OwnAddress1 = 238;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Analogue filter
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Digital filter
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C2_Init 2 */
#endif
  /* USER CODE END I2C2_Init 2 */

}

/**
  * @brief ICACHE Initialization Function
  * @param None
  * @retval None
  */
static void MX_ICACHE_Init(void)
{

  /* USER CODE BEGIN ICACHE_Init 0 */

  /* USER CODE END ICACHE_Init 0 */

  /* USER CODE BEGIN ICACHE_Init 1 */

  /* USER CODE END ICACHE_Init 1 */

  /** Enable instruction cache in 1-way (direct mapped cache)
  */
  if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_ICACHE_Enable() != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ICACHE_Init 2 */

  /* USER CODE END ICACHE_Init 2 */

}

/**
  * @brief IWDG Initialization Function
  * @param None
  * @retval None
  */
static void MX_IWDG_Init(void)
{

  /* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
  /* USER CODE END IWDG_Init 0 */

  /* USER CODE BEGIN IWDG_Init 1 */

  /* USER CODE END IWDG_Init 1 */
  hiwdg.Instance = IWDG;
  hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
  hiwdg.Init.Window = 4095;
  hiwdg.Init.Reload = 1000;
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN IWDG_Init 2 */
#endif
  /* USER CODE END IWDG_Init 2 */

}

/**
  * @brief LPUART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_LPUART1_UART_Init(void)
{

  /* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
  /* USER CODE END LPUART1_Init 0 */

  /* USER CODE BEGIN LPUART1_Init 1 */

  /* USER CODE END LPUART1_Init 1 */
  hlpuart1.Instance = LPUART1;
  hlpuart1.Init.BaudRate = 115200;
  hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
  hlpuart1.Init.Parity = UART_PARITY_NONE;
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
  hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
  if (HAL_UART_Init(&hlpuart1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN LPUART1_Init 2 */
#endif
  /* USER CODE END LPUART1_Init 2 */

}

/**
  * @brief RNG Initialization Function
  * @param None
  * @retval None
  */
static void MX_RNG_Init(void)
{

  /* USER CODE BEGIN RNG_Init 0 */

  /* USER CODE END RNG_Init 0 */

  /* USER CODE BEGIN RNG_Init 1 */

  /* USER CODE END RNG_Init 1 */
  hrng.Instance = RNG;
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
  if (HAL_RNG_Init(&hrng) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN RNG_Init 2 */

  /* USER CODE END RNG_Init 2 */

}

/**
  * @brief SPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI2_Init(void)
{

  /* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  /* SPI2 parameter configuration*/
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 7;
  hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI2_Init 2 */
#endif
  /* USER CODE END SPI2_Init 2 */

}

/**
  * @brief TIM6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM6_Init(void)
{

  /* USER CODE BEGIN TIM6_Init 0 */

  /* USER CODE END TIM6_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM6_Init 1 */

  /* USER CODE END TIM6_Init 1 */
  htim6.Instance = TIM6;
  htim6.Init.Prescaler = 9999;
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim6.Init.Period = 7999;
  htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM6_Init 2 */

  /* USER CODE END TIM6_Init 2 */

}

/**
  * @brief TIM7 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM7_Init(void)
{

  /* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
  /* USER CODE END TIM7_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM7_Init 1 */

  /* USER CODE END TIM7_Init 1 */
  htim7.Instance = TIM7;
  htim7.Init.Prescaler = 0;
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim7.Init.Period = 7999;
  htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM7_Init 2 */
#endif
  /* USER CODE END TIM7_Init 2 */

}

/**
  * @brief TIM16 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM16_Init(void)
{

  /* USER CODE BEGIN TIM16_Init 0 */

  /* USER CODE END TIM16_Init 0 */

  /* USER CODE BEGIN TIM16_Init 1 */

  /* USER CODE END TIM16_Init 1 */
  htim16.Instance = TIM16;
  htim16.Init.Prescaler = 79;
  htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim16.Init.Period = 65535;
  htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim16.Init.RepetitionCounter = 0;
  htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM16_Init 2 */

  /* USER CODE END TIM16_Init 2 */

}

/**
  * @brief USB Initialization Function
  * @param None
  * @retval None
  */
static void MX_USB_PCD_Init(void)
{

  /* USER CODE BEGIN USB_Init 0 */

  /* USER CODE END USB_Init 0 */

  /* USER CODE BEGIN USB_Init 1 */

  /* USER CODE END USB_Init 1 */
  hpcd_USB_FS.Instance = USB;
  hpcd_USB_FS.Init.dev_endpoints = 8;
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
  hpcd_USB_FS.Init.Sof_enable = DISABLE;
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USB_Init 2 */

  /* USER CODE END USB_Init 2 */

}

/**
  * Enable DMA controller clock
  */
static void MX_DMA_Init(void)
{

  /* DMA controller clock enable */
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
  __HAL_RCC_DMA1_CLK_ENABLE();
  __HAL_RCC_DMA2_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
  /* DMA1_Channel2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
  /* DMA2_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
  HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin|ECUC_BOOT0_Pin|ECUD_BOOT0_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin|Other_nCS_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin|LCD_DC_Pin|ECUB_EN_Pin|FDCAN1_STB_Pin
                          |ECUB_BOOT0_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
  GPIO_InitStruct.Pin = ECUC_EN_Pin|ECUC_BOOT0_Pin|ECUD_BOOT0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

  /*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
  GPIO_InitStruct.Pin = ECUD_EN_Pin|Other_nCS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
                           ECUB_BOOT0_Pin */
  GPIO_InitStruct.Pin = LCD_nCS_Pin|LCD_DC_Pin|ECUB_EN_Pin|FDCAN1_STB_Pin
                          |ECUB_BOOT0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : SELF_BOOT0_Pin */
  GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{

	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK) Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK) Error_Handler();
		}
		else Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	//if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		//Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if(RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle,&xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	//TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if(uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) //Don't forward empty commands or commands longer than buffer
		{
			if(UART_RxStreamBufferHandle != NULL){

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle,&uart_current_index, 2U, NULL ) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle,UART_recvBuf, uart_current_index, NULL ) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle,&xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
  /* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for(;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE)) invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void*)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength) invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True) RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else RAMN_USB_SendFromTask((uint8_t*)"\a",1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True) USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True) USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for(;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY );
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void*)UARTRxBuffer, commandLength,portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);

	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
  /* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
  /* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for(;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader,sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *) CANRxData,payloadSize, portMAX_DELAY ) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if(CANRxHeader.RxFrameType == FDCAN_DATA_FRAME) {
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier,payloadSize,(RAMN_CANFrameData_t*)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U) RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t*)RTRTxData,(uint8_t*)HARDWARE_UNIQUE_ID_ADDRESS,8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader,RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if(CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if(CANRxHeader.BitRateSwitch  == FDCAN_BRS_ON) slCAN_USBTxBuffer[index++] = '1';
					else slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U) payloadSize = 8U;
				}

				if(CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; //no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier,&slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier,&slCAN_USBTxBuffer[index]);
				}

				//TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF,&slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF,&slCAN_USBTxBuffer[index]);
				}

				for(uint8_t i=0;i<payloadSize;i++)
				{
					index += uint8toASCII(CANRxData[i],&slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60,&slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer,index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
			{
				if(RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

	}
  /* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
  /* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for(;;)
	{
		uint32_t index = 0;
		while(index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader+index),sizeof(CANTxHeader)-index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME) payloadSize = 0U;  // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while(index < payloadSize) index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData+index),payloadSize-index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY );
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;

	}
  /* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
  /* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK) Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t*)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); 	// Enable custom function timer
	HAL_TIM_Base_Start(&htim16); 	// Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for(;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if(HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined (ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
  /* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
  /* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	//TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for(;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1,&protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True) RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if(err & HAL_FDCAN_ERROR_PROTOCOL_DATA) RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
  /* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
  /* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for(;;)
	{
#ifdef ENABLE_UDS
		//Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing,sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize,sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index],diagRxSize-index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *) &diagTxSize, sizeof(diagTxSize), portMAX_DELAY );
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *) diagTxbuf, diagTxSize, portMAX_DELAY );
									if(xBytesSent != (diagTxSize + sizeof(diagTxSize) ))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *) &diagTxSize, sizeof(diagTxSize), portMAX_DELAY );
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *) diagTxbuf, diagTxSize, portMAX_DELAY );
										if( xBytesSent != (diagTxSize + sizeof(diagTxSize) ))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize,sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf+index,diagRxSize-index, portMAX_DELAY);
					}


					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *) &diagTxSize, sizeof(diagTxSize), portMAX_DELAY );
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *) diagTxbuf, diagTxSize, portMAX_DELAY );
						if( xBytesSent != (diagTxSize + sizeof(diagTxSize) ))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize,sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf+index,diagRxSize-index, portMAX_DELAY);
					}


					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *) &diagTxSize, sizeof(diagTxSize), portMAX_DELAY );
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *) diagTxbuf, diagTxSize, portMAX_DELAY );
						if( xBytesSent != (diagTxSize + sizeof(diagTxSize) ))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
  /* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
  /* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for(;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize),sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) //TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData+index),RAMN_UDS_ISOTPHandler.txSize-index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}

				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize),sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) //TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData+index),RAMN_KWP_ISOTPHandler.txSize-index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}

				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t  XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize),sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) //TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload+index),diagTxSize-index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(),XCP_payload,diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}

			}

		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
  /* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
  /* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle,&RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	//We expect a notification from the serial close/open detection module
	//ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK) osDelay(10U); //Wait for TX to be ready
#endif
	/* Infinite loop */
	for(;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle,USBIntermediateTxBuffer,sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer,size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle,&RAMN_SendUSBHandle);
	for(;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle,UARTIntermediateTxBuffer,sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1,UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
  /* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
  /* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t            ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for(;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			//recvFrame->echo_id
			//recvFrame.flags
			//recvFrame.reserved


			CANTxHeader.Identifier = (recvFrame->can_id)&0x1FFFFFFF;
			CANTxHeader.DataLength  = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG) CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG) CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			//CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			//TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader,CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
  /* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
  /* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t            ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for(;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if(ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if(ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if(uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if(ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
  /* USER CODE END RAMN_TxTask2Func */
}

/**
  * @brief  Period elapsed callback in non blocking mode
  * @note   This function is called  when TIM1 interrupt took place, inside
  * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
    HAL_IncTick();
  }
  /* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

  /* USER CODE END Callback 1 */
}

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{

	}
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

Looks like the firmware is hitting Error_Handler before tasks start. I added a Renode-only UART heartbeat path; compile with RENODE_SIM to bypass the failing inits and verify UART.

- In STM32CubeIDE: Project > Properties > C/C++ Build > Settings > Tool Settings > MCU GCC Compiler > Symbols ‚Üí Add: RENODE_SIM
- Rebuild and run Renode:
  - Monitor: i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  - Optional: cpu LogFunctionNames false (to stop the spam)

You should now see ‚ÄúHello from RAMN‚Äù every ~second in the LPUART1 analyzer.

If still quiet:
- Confirm ENABLE_UART is defined and USB/CDC disabled in ramn_config.h.
- In Renode monitor: showAnalyzer sysbus.lpuart1
- Ensure RENODE_SIM appears in the build command line (GCC ‚Äú-DRENODE_SIM‚Äù).

---

**User**

07:52:35.3792 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80007AC
07:52:35.3792 [INFO] cpu: Entering function Error_Handler (entry) at 0x800088C
07:52:35.3793 [INFO] cpu: Entering function Error_Handler at 0x8000892
07:52:35.3793 [INFO] cpu: Entering function Error_Handler at 0x8000894

---

**Cursor**

I'll guard the FIFO configuration calls in `MX_LPUART1_UART_Init` with `#ifndef RENODE_SIM` so UART init won't fail under Renode. Then you can rebuild with `-DRENODE_SIM` and rerun.

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
 static void MX_LPUART1_UART_Init(void)
 {
@@
 #ifdef ENABLE_UART
@@
   if (HAL_UART_Init(&hlpuart1) != HAL_OK)
   {
     Error_Handler();
   }
+#ifndef RENODE_SIM
   if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
   {
     Error_Handler();
   }
   if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
   {
     Error_Handler();
   }
   if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
   {
     Error_Handler();
   }
+#endif
   /* USER CODE BEGIN LPUART1_Init 2 */
 #endif
   /* USER CODE END LPUART1_Init 2 */
 
 }
*** End Patch
PATCH
```

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Minimal Renode path: initialize only UART and print periodically
	MX_LPUART1_UART_Init();
	const uint8_t msg[] = "Hello from RAMN\r";
	for (;;)
	{
		HAL_UART_Transmit(&hlpuart1, (uint8_t *)msg, sizeof(msg) - 1, 0xFFFF);
		// crude delay loop (~1s depending on Renode speed)
		for (volatile uint32_t d = 0; d < 800000; ++d)
		{
		}
	}
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
	/* USER CODE END LPUART1_Init 0 */

	/* USER CODE BEGIN LPUART1_Init 1 */

	/* USER CODE END LPUART1_Init 1 */
	hlpuart1.Instance = LPUART1;
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

You‚Äôre tripping Error_Handler inside `MX_LPUART1_UART_Init` during the FIFO threshold/disabling calls. I‚Äôve wrapped those in `#ifndef RENODE_SIM` so they‚Äôre skipped in Renode.

Do this:
- Rebuild with RENODE_SIM defined (ensure the compile line shows `-DRENODE_SIM`).
- Run your Renode script again. With our earlier minimal loop, you should now see ‚ÄúHello from RAMN‚Äù in the LPUART1 analyzer.

If it still errors at `HAL_UART_Init`:
- In Renode monitor, set a simpler clock for LPUART1 if needed:
  - Ensure `lpuart1` frequency is `80000000` in `stm32l552_ramn_mac.repl` (already set).
- Turn off function logging noise:
  - `cpu LogFunctionNames false`

---

**User**

how do i add renode sim to the build again?

---

**Cursor**

- STM32CubeIDE (recommended)
  - Right‚Äëclick project RAMNV1 ‚Üí Properties.
  - C/C++ Build ‚Üí Settings ‚Üí Tool Settings.
  - MCU GCC Compiler ‚Üí Preprocessor (or Symbols).
  - Add a new symbol: RENODE_SIM
  - Apply ‚Üí Clean Project ‚Üí Build. Verify the build console shows -DRENODE_SIM in gcc calls.

- Optional: separate config
  - Project ‚Üí Build Configurations ‚Üí Manage‚Ä¶ ‚Üí New (copy Debug) ‚Üí name it ‚ÄúRenode‚Äù.
  - Add the RENODE_SIM symbol only to this config, then build that config.

- Quick temporary alternative (not ideal)
  - Add at the top of `Core/Inc/ramn_config.h` after the header guard:
    ```
    #define RENODE_SIM
    ```
  - Rebuild. Remove when not using Renode.

```plaintext
    #define RENODE_SIM
    ```
  - Rebuild. Remove when not using Renode.
```

---

**User**

08:03:03.3678 [INFO] cpu: Entering function UART_SetConfig at 0x8006F80
08:03:03.3680 [WARNING] lpuart1: Unhandled read from offset 0x2C.
08:03:03.3684 [WARNING] lpuart1: Unhandled write to offset 0x2C, value 0x0.
08:03:03.3684 [INFO] cpu: Entering function UART_SetConfig at 0x8007004


...
08:03:03.3707 [INFO] cpu: Entering function HAL_UART_Init at 0x800677C
08:03:03.3708 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80007A6
08:03:03.3708 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80007AC
08:03:03.3709 [INFO] cpu: Entering function Error_Handler (entry) at 0x8000858
08:03:03.3712 [INFO] cpu: Entering function Error_Handler at 0x800085E
08:03:03.3713 [INFO] cpu: Entering function Error_Handler at 0x8000860
08:03:03.3838 [INFO] cpu: Entering function Error_Handler at 0x8000860 (1406)
08:03:03.3839 [INFO] cpu: Entering function Error_Handler at 0x8000862



---

**Cursor**

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
    // Minimal Renode path: write directly to LPUART1 TDR (offset 0x28)
    volatile uint32_t *const LPUART1_TDR = (uint32_t *)(0x40008000u + 0x28u);
    const char msg[] = "Hello from RAMN\r";
    for (;;)
    {
        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
        {
            *LPUART1_TDR = (uint32_t)msg[i];
        }
        // crude delay loop (~1s depending on Renode speed)
        for (volatile uint32_t d = 0; d < 800000; ++d)
        {
        }
    }
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
	/* USER CODE END LPUART1_Init 0 */

	/* USER CODE BEGIN LPUART1_Init 1 */

	/* USER CODE END LPUART1_Init 1 */
	hlpuart1.Instance = LPUART1;
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

- Root cause: the Renode peripheral is `UART.STM32F7_USART`, which doesn‚Äôt implement LPUART‚Äôs PRESC register (offset 0x2C). HAL tries to touch it ‚Üí HAL_UART_Init fails ‚Üí Error_Handler.

Do this to see UART now
1) Define RENODE_SIM for your Debug build so the Renode-only code path writes directly to LPUART1‚Äôs TDR and skips HAL init:
   - STM32CubeIDE ‚Üí Project Properties ‚Üí C/C++ Build ‚Üí Settings ‚Üí Tool Settings ‚Üí MCU GCC Compiler ‚Üí Preprocessor/Symbols ‚Üí Add: RENODE_SIM
   - Clean and rebuild. Confirm the build log shows -DRENODE_SIM.
   - Run Renode: i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
   - Optional: cpu LogFunctionNames false

2) Quick fallback (if IDE symbol is tedious): temporarily add this near the top of `Core/Inc/ramn_config.h` after the include guard:
   - `#define RENODE_SIM`
   - Rebuild and run Renode.

You should then see ‚ÄúHello from RAMN‚Äù in the `sysbus.lpuart1` analyzer every ~second.

---

**User**

I added RENODE_SIM, this is the build log. is it fine?

08:01:45 **** Incremental Build of configuration Debug for project RAMNV1 ****
make -j7 all 
arm-none-eabi-gcc "../Core/Src/main.c" -mcpu=cortex-m33 -std=gnu11 -g3 -DDEBUG -DUSE_HAL_DRIVER -DSTM32L552xx -DRENODE_SIM -c -I../Core/Inc -I../Middlewares/ST/EEPROM_Emul/Core -I../Middlewares/ST/EEPROM_Emul/Porting/STM32L5 -I../Drivers/STM32L5xx_HAL_Driver/Inc -I../Drivers/STM32L5xx_HAL_Driver/Inc/Legacy -I../Drivers/CMSIS/Device/ST/STM32L5xx/Include -I../Drivers/CMSIS/Include -I../Middlewares/Third_Party/FreeRTOS/Source/include -I../Middlewares/ST/STM32_USB_Device_Library/USBCore/Inc -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/gs_usb -I../Middlewares/ST/STM32_USB_Device_Library/USBClass/Composite/CDC -I../USB_CompositeDevice/App -I../USB_CompositeDevice/Target -I../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS_V2 -I../Middlewares/Third_Party/FreeRTOS/Source/portable/GCC/ARM_CM33_NTZ/non_secure -O0 -ffunction-sections -fdata-sections -Wall -pedantic -fstack-usage -fcyclomatic-complexity -MMD -MP -MF"Core/Src/main.d" -MT"Core/Src/main.o" --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -o "Core/Src/main.o"
../Core/Src/main.c: In function 'main':
../Core/Src/main.c:567:43: warning: binary constants are a C2X feature or GCC extension
  567 |                         uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
arm-none-eabi-gcc -o "RAMNV1.elf" @"objects.list"   -mcpu=cortex-m33 -T"/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/STM32L552CETX_FLASH.ld" --specs=nosys.specs -Wl,-Map="RAMNV1.map" -Wl,--gc-sections -static --specs=nano.specs -mfpu=fpv5-sp-d16 -mfloat-abi=hard -mthumb -Wl,--start-group -lc -lm -Wl,--end-group
      |                                           ^~~~
../Core/Src/main.c: In function 'HAL_UART_RxCpltCallback':
../Core/Src/main.c:1455:40: warning: passing argument 2 of 'HAL_UART_Receive_IT' from incompatible pointer type [-Wincompatible-pointer-types]
 1455 |         HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
      |                                        ^~~~~~~~~~~~~
      |                                        |
      |                                        uint8_t (*)[1] {aka unsigned char (*)[1]}
In file included from ../Core/Inc/stm32l5xx_hal_conf.h:402,
                 from ../Drivers/STM32L5xx_HAL_Driver/Inc/stm32l5xx_hal.h:30,
                 from ../Core/Inc/main.h:33,
                 from ../Core/Src/main.c:24:
../Drivers/STM32L5xx_HAL_Driver/Inc/stm32l5xx_hal_uart.h:1637:75: note: expected 'uint8_t *' {aka 'unsigned char *'} but argument is of type 'uint8_t (*)[1]' {aka 'unsigned char (*)[1]'}
 1637 | HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
      |                                                                  ~~~~~~~~~^~~~~
../Core/Src/main.c: In function 'RAMN_ReceiveUSBFunc':
../Core/Src/main.c:1514:40: warning: passing argument 2 of 'HAL_UART_Receive_IT' from incompatible pointer type [-Wincompatible-pointer-types]
 1514 |         HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)
      |                                        ^~~~~~~~~~~~~
      |                                        |
      |                                        uint8_t (*)[1] {aka unsigned char (*)[1]}
../Drivers/STM32L5xx_HAL_Driver/Inc/stm32l5xx_hal_uart.h:1637:75: note: expected 'uint8_t *' {aka 'unsigned char *'} but argument is of type 'uint8_t (*)[1]' {aka 'unsigned char (*)[1]'}
 1637 | HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size);
      |                                                                  ~~~~~~~~~^~~~~
/Applications/STM32CubeIDE.app/Contents/Eclipse/plugins/com.st.stm32cube.ide.mcu.externaltools.gnu-tools-for-stm32.13.3.rel1.macos64_1.0.0.202411102158/tools/bin/../lib/gcc/arm-none-eabi/13.3.1/../../../../arm-none-eabi/bin/ld: warning: RAMNV1.elf has a LOAD segment with RWX permissions
Finished building target: RAMNV1.elf
 
arm-none-eabi-size  RAMNV1.elf 
arm-none-eabi-objdump -h -S RAMNV1.elf  > "RAMNV1.list"
arm-none-eabi-objcopy  -O ihex RAMNV1.elf  "RAMNV1.hex"
arm-none-eabi-objcopy  -O binary RAMNV1.elf  "RAMNV1.bin"
   text	   data	    bss	    dec	    hex	filename
  48276	    184	  23920	  72380	  11abc	RAMNV1.elf
Finished building: default.size.stdout
 
Finished building: RAMNV1.hex
Finished building: RAMNV1.bin
 
 
Finished building: RAMNV1.list
 

08:01:48 Build Finished. 0 errors, 4 warnings. (took 2s.677ms)

---

**Cursor**

Yes‚Äîlooks good. The compile line includes -DRENODE_SIM and the build completed with 0 errors.

- The warnings are OK for Renode:
  - C2X binary literal: harmless.
  - Two HAL_UART_Receive_IT pointer warnings are from using &uart_rx_data instead of uart_rx_data; not used in RENODE_SIM path. If you want to silence them later, pass uart_rx_data (no ampersand) in both spots.

Next: run Renode and open the UART
- In Renode monitor: i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
- If noisy: cpu LogFunctionNames false
- Ensure the analyzer is open: showAnalyzer sysbus.lpuart1

You should see ‚ÄúHello from RAMN‚Äù printed periodically.

---

**User**

still nothing on sysbus

08:16:42.9898 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x800500C
08:16:42.9898 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8005018
08:16:42.9899 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8005034
08:16:42.9899 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8005044
08:16:42.9899 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8005060
08:16:42.9900 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x80050F4
08:16:42.9900 [INFO] cpu: Entering function HAL_RCC_GetHCLKFreq at 0x800511C
08:16:42.9900 [INFO] cpu: Entering function HAL_RCC_GetPCLK1Freq at 0x8005144
08:16:42.9900 [INFO] cpu: Entering function UART_SetConfig at 0x8007254
08:16:42.9901 [INFO] cpu: Entering function UART_SetConfig at 0x8007282
08:16:42.9903 [INFO] cpu: Entering function UART_SetConfig at 0x800728A
08:16:42.9904 [INFO] cpu: Entering function UART_SetConfig at 0x80072BA
08:16:42.9905 [INFO] cpu: Entering function UART_SetConfig at 0x80074EA
08:16:42.9906 [INFO] cpu: Entering function HAL_UART_Init at 0x800673A
08:16:42.9907 [INFO] cpu: Entering function HAL_UART_Init at 0x8006740
08:16:42.9909 [INFO] cpu: Entering function HAL_UART_Init at 0x800677C
08:16:42.9910 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80007A6
08:16:42.9911 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80007AC
08:16:42.9911 [INFO] cpu: Entering function Error_Handler (entry) at 0x8000858
08:16:42.9912 [INFO] cpu: Entering function Error_Handler at 0x800085E
08:16:42.9913 [INFO] cpu: Entering function Error_Handler at 0x8000860

---

**Cursor**

I‚Äôm going to set UE and TE in LPUART1_CR1 and a minimal BRR value in the RENODE_SIM block so the Renode UART model is enabled before writing TDR. Then rebuild and rerun.

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
    // Minimal Renode path: enable LPUART1 and write directly to TDR
    volatile uint32_t *const LPUART1_CR1 = (uint32_t *)(0x40008000u + 0x00u);
    volatile uint32_t *const LPUART1_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
    volatile uint32_t *const LPUART1_TDR = (uint32_t *)(0x40008000u + 0x28u);

    // UE (bit 13) | TE (bit 3)
    *LPUART1_CR1 = (1u << 13) | (1u << 3);
    // Set a non-zero BRR divider (value not critical for Renode model)
    *LPUART1_BRR = 0x1u;

    const char msg[] = "Hello from RAMN\r";
    for (;;)
    {
        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
        {
            *LPUART1_TDR = (uint32_t)msg[i];
        }
        // crude delay loop (~1s depending on Renode speed)
        for (volatile uint32_t d = 0; d < 800000; ++d)
        {
        }
    }
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
	/* USER CODE END LPUART1_Init 0 */

	/* USER CODE BEGIN LPUART1_Init 1 */

	/* USER CODE END LPUART1_Init 1 */
	hlpuart1.Instance = LPUART1;
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

Rebuild and rerun with the analyzer open:

- Build confirms `-DRENODE_SIM` is present (good).
- In Renode monitor:
  - `i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc`
  - If noisy: `cpu LogFunctionNames false`
  - Ensure: `showAnalyzer sysbus.lpuart1`

I‚Äôve now explicitly enabled LPUART1 in the Renode path by setting `CR1.UE|TE` and a minimal `BRR` before writing `TDR`. You should see ‚ÄúHello from RAMN‚Äù printed repeatedly. If still blank, try hitting Reset in Renode (`system Reset`) and confirm the analyzer is on `lpuart1` (not `usart1`).

---

**User**

nothing shoing up on sysbus. should i type in something? like start or something

---

**Cursor**

- You don‚Äôt need to type into the analyzer; it should display output automatically.
- Your logs still show HAL init paths, which means Renode is likely running an old ELF. Reload the new ELF and restart.

Do this in Renode monitor:
- pause
- sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf
- showAnalyzer sysbus.lpuart1
- cpu LogFunctionNames false
- start

If still no output, fully recreate the machine:
- mach clear
- i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc

You should now see ‚ÄúHello from RAMN‚Äù periodically.

---

**User**

nope, nothing. I'm running on latest elf (I'm assuming stm32cube replaces the elf when i rebuild). the terminal logger is just shoing this

08:38:01.3320 [INFO] cpu: Entering function main at 0x80002E2
08:38:01.3439 [INFO] cpu: Entering function main at 0x80002E2 (2856)
08:38:01.3440 [INFO] cpu: Entering function main at 0x80002EA
08:38:01.3440 [INFO] cpu: Entering function main at 0x80002E2
08:38:01.3516 [INFO] cpu: Entering function main at 0x80002E2 

and nithing on sysbus or anything. should i type something in the (ecu0) terminal?

---

**Cursor**

I'll adjust the RENODE_SIM block to write to the STM32F7-style USART registers that Renode's `UART.STM32F7_USART` model expects (DR at 0x04, BRR at 0x08, CR1 at 0x0C). Then you can rebuild and reload the ELF.

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
    // Minimal Renode path matching UART.STM32F7_USART register map
    // Base: 0x40008000 (LPUART1)
    // DR @ +0x04, BRR @ +0x08, CR1 @ +0x0C
    volatile uint32_t *const USART_DR  = (uint32_t *)(0x40008000u + 0x04u);
    volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x08u);
    volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x0Cu);

    // Enable USART and transmitter: UE (bit 13) | TE (bit 3)
    *USART_CR1 = (1u << 13) | (1u << 3);
    // Non-zero baud divider
    *USART_BRR = 0x1u;

    const char msg[] = "Hello from RAMN\r";
    for (;;)
    {
        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
        {
            *USART_DR = (uint32_t)msg[i];
        }
        for (volatile uint32_t d = 0; d < 800000; ++d) { }
    }
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
	/* USER CODE END LPUART1_Init 0 */

	/* USER CODE BEGIN LPUART1_Init 1 */

	/* USER CODE END LPUART1_Init 1 */
	hlpuart1.Instance = LPUART1;
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

Rebuild and reload the ELF, then in the Renode monitor:

- pause
- sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf
- showAnalyzer sysbus.lpuart1
- cpu LogFunctionNames false
- start

I switched the RENODE_SIM writes to the STM32F7 USART offsets (DR +0x04, BRR +0x08, CR1 +0x0C) that Renode‚Äôs `UART.STM32F7_USART` model expects. You shouldn‚Äôt need to type anything; output should appear automatically.

---

**User**

(monitor) sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAM
NV1.elf
No such command or device: sysbus

---

**Cursor**

You‚Äôre in a monitor with no machine, so sysbus doesn‚Äôt exist. Load the machine first, then the ELF.

Fastest: run the RESC (one single line!)
- i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc

Manual steps (if you prefer):
- mach clear
- mach create "ecu0"
- machine LoadPlatformDescription @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/stm32l552_ramn_mac.repl
- sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf
- showAnalyzer sysbus.lpuart1
- cpu LogFunctionNames false
- start

Note: enter paths on one line (no wrapping). You don‚Äôt need to type into the analyzer; text should appear automatically.

---

**User**

alright man, once again, nothing shows. Can you explain the problem and what you have been trying to do to fix it? Also, can you run grep or search the codebase and confirm that we're on the right UART Peripheral? Btw, these are the logs

09:01:12.5149 [INFO] cpu: Entering function main at 0x80002C0
09:01:12.5150 [WARNING] lpuart1: Unhandled write to offset 0x4. Unhandled bits: [5] when writing value 0x20. Tags: LBDL (0x1).
09:01:12.5150 [INFO] cpu: Entering function main at 0x80002C0
09:01:12.5150 [WARNING] lpuart1: Unhandled write to offset 0x4. Unhandled bits: [1, 4, 6] when writing value 0x52. Tags: RESERVED (0x2), ADDM7 (0x1), LBDIE (0x1).
09:01:12.5150 [INFO] cpu: Entering function main at 0x80002C0
09:01:12.5151 [WARNING] lpuart1: Unhandled write to offset 0x4. Unhandled bits: [0, 6] when writing value 0x41. Tags: RESERVED (0x1), LBDIE (0x1).
09:01:12.5151 [INFO] cpu: Entering function main at 0x80002C0
09:01:12.5151 [WARNING] lpuart1: Unhandled write to offset 0x4. Unhandled bits: [0, 2-3, 6] when writing value 0x4D. Tags: RESERVED (0xD), LBDIE (0x1).
09:01:12.5151 [INFO] cpu: Entering function main at 0x80002C0
09:01:12.5152 [WARNING] lpuart1: Unhandled write to offset 0x4. Unhandled bits: [1-3, 6] when writing value 0x4E. Tags: RESERVED (0xE), LBDIE (0x1).
09:01:12.5152 [INFO] cpu: Entering function main at 0x80002C0
09:01:12.5152 [WARNING] lpuart1: Unhandled write to offset 0x4. Unhandled bits: [0, 2-3] when writing value 0xD. Tags: RESERVED (0xD).
09:01:12.5152 [INFO] cpu: Entering function main at 0x80002DC
09:01:12.5153 [INFO] cpu: Entering function main at 0x80002E8
09:01:12.5153 [INFO] cpu: Entering function main at 0x80002E2
09:01:12.5156 [INFO] cpu: Entering function main at 0x80002E2 (286)

---

**Cursor**

Let me confirm which UART the firmware uses and adjust the RENODE_SIM register addresses so writes go to the correct TDR. Then I‚Äôll outline the exact test steps.

I verified via search that the firmware uses LPUART1. I‚Äôll now update the RENODE_SIM block to use the L4/L5 register map (CR1 @ 0x00, BRR @ 0x0C, TDR @ 0x28) instead of the F7 DR offset to match Renode‚Äôs warnings, so the analyzer gets proper TX writes. Then you can rebuild and reload.

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
-#ifdef RENODE_SIM
-    // Minimal Renode path matching UART.STM32F7_USART register map
-    // Base: 0x40008000 (LPUART1)
-    // DR @ +0x04, BRR @ +0x08, CR1 @ +0x0C
-    volatile uint32_t *const USART_DR  = (uint32_t *)(0x40008000u + 0x04u);
-    volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x08u);
-    volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x0Cu);
-
-    // Enable USART and transmitter: UE (bit 13) | TE (bit 3)
-    *USART_CR1 = (1u << 13) | (1u << 3);
-    // Non-zero baud divider
-    *USART_BRR = 0x1u;
-
-    const char msg[] = "Hello from RAMN\r";
-    for (;;)
-    {
-        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
-        {
-            *USART_DR = (uint32_t)msg[i];
-        }
-        for (volatile uint32_t d = 0; d < 800000; ++d) { }
-    }
-#endif
+#ifdef RENODE_SIM
+    // Minimal Renode path for STM32L4/L5 style USART register map
+    // Base: 0x40008000 (LPUART1)
+    // CR1 @ +0x00, BRR @ +0x0C, TDR @ +0x28
+    volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
+    volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
+    volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);
+
+    // Enable USART and transmitter: UE (bit 13) | TE (bit 3)
+    *USART_CR1 = (1u << 13) | (1u << 3);
+    // Non-zero baud divider
+    *USART_BRR = 0x1u;
+
+    const char msg[] = "Hello from RAMN\r";
+    for (;;)
+    {
+        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
+        {
+            *USART_TDR = (uint32_t)msg[i];
+        }
+        for (volatile uint32_t d = 0; d < 800000; ++d) { }
+    }
+#endif
*** End Patch
PATCH
```

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
	volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
	volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
	volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);

	*USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
	*USART_BRR = 0x1u; // minimal baud divider

	const char msg[] = "Hello from RAMN\r";
	for (;;)
	{
		for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
		{
			*USART_TDR = (uint32_t)msg[i];
		}
		for (volatile uint32_t d = 0; d < 800000; ++d) { }
	}
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
	/* USER CODE END LPUART1_Init 0 */

	/* USER CODE BEGIN LPUART1_Init 1 */

	/* USER CODE END LPUART1_Init 1 */
	hlpuart1.Instance = LPUART1;
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

Here‚Äôs what‚Äôs going on and what we tried:

- Problem in short: The firmware uses LPUART1. Renode‚Äôs `UART.STM32F7_USART` model doesn‚Äôt fully match STM32L5 LPUART registers. HAL init touches unsupported registers (e.g., PRESC at 0x2C), causing Error_Handler loops. Even when we bypass HAL and write directly, earlier we used the F7 DR offset; Renode logs show writes landing on wrong offsets.

- What we did:
  - Confirmed the active UART is LPUART1:
    - `MX_LPUART1_UART_Init` sets `hlpuart1.Instance = LPUART1`.
    - MSP config enables LPUART1 clocks/pins/IRQ.
  - Pointed your Renode platform to `lpuart1` at base 0x40008000 and attached analyzer.
  - Disabled USB-CDC and enabled `ENABLE_UART`.
  - Added `RENODE_SIM` build flag and a minimal UART path that:
    - Skips HAL init.
    - Direct-writes to the UART registers.
  - Adjusted the register addresses to the STM32L5 layout Renode logs hinted at:
    - CR1 @ 0x00, BRR @ 0x0C, TDR @ 0x28
    - Set UE|TE and BRR, then write characters to TDR in a loop.

- Why the warnings mattered:
  - Your Renode log showed ‚ÄúUnhandled write to offset 0x4 ‚Ä¶ Tags: LBDx‚Äù which corresponds to a different register mapping than we first used. We‚Äôve now aligned writes to CR1/BRR/TDR at 0x00/0x0C/0x28.

What to do now
1) Rebuild to include latest RENODE_SIM change (confirm `-DRENODE_SIM` appears in the first gcc call).
2) In Renode monitor:
   - mach clear
   - i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
   - showAnalyzer sysbus.lpuart1
   - cpu LogFunctionNames false
   - start

You do not need to type in the analyzer; it should show ‚ÄúHello from RAMN‚Äù repeatedly if the writes hit TDR.

If still nothing
- Ensure the analyzer title is exactly lpuart1 (not usart1).
- Try: `sysbus WriteDoubleWord 0x4000800C 0x1` and `sysbus WriteDoubleWord 0x40008000 0x2008` to set BRR and CR1, then `sysbus WriteDoubleWord 0x40008028 0x41` to send 'A'. If that prints in the analyzer, the register map is correct and the firmware should too.
- If manual writes print but firmware doesn‚Äôt, confirm your ELF is reloaded after rebuild and RENODE_SIM code is compiled in.

---

**User**

ok, I want you to see the terminal logs. Run this command to start renode, and I'll add the input to the monitor

/Applications/Renode.app/Contents/MacOS/macos_run.command ; exit;


---

**Cursor**

Starting Renode now so you can paste your monitor commands. I'll run it in the background so our session stays open.

Renode is running. Paste your monitor commands, and I‚Äôll watch for the logs you get back.

---

**User**

pasted

---

**Cursor**

- Short diagnosis: The firmware uses LPUART1. Renode‚Äôs UART model you‚Äôre using doesn‚Äôt fully match LPUART‚Äôs registers, so HAL init and our early direct-writes aren‚Äôt producing output. Your logs also show main being re-entered a lot, which suggests we‚Äôre not actually hitting the RENODE_SIM loop or we‚Äôre resetting early.

- Confirmed UART choice (LPUART1) in code:
```1029:1034:firmware/RAMNV1/Core/Src/main.c
hlpuart1.Instance = LPUART1;
hlpuart1.Init.BaudRate = 115200;
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
```

```427:459:firmware/RAMNV1/Core/Src/stm32l5xx_hal_msp.c
if(huart->Instance==LPUART1) {
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
  __HAL_RCC_LPUART1_CLK_ENABLE();
  // PA2 TX, PA3 RX, AF8_LPUART1
}
```

What I‚Äôve tried so far (and why)
- Enabled LPUART1 in Renode platform and opened the analyzer.
- Switched the build to UART-only (no USB) and added RENODE_SIM to bypass HAL (HAL touches unsupported LPUART regs in Renode).
- Wrote straight to UART regs from main; first with F7-style offsets, then with L4/L5-style (CR1 0x00, BRR 0x0C, TDR 0x28) to match your warnings. Still silent.

Quick, definitive test in Renode monitor
- First clear + load platform:
  - mach clear
  - i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  - showAnalyzer sysbus.lpuart1
  - pause
- Try L4/L5 map (CR1/BRR/TDR):
  - sysbus WriteDoubleWord 0x40008000 0x2008
  - sysbus WriteDoubleWord 0x4000800C 0x1
  - sysbus WriteDoubleWord 0x40008028 0x41
- If nothing prints, try the F7 map (CR1/BRR/DR at 0x0C/0x08/0x04):
  - sysbus WriteDoubleWord 0x4000800C 0x2008
  - sysbus WriteDoubleWord 0x40008008 0x1
  - sysbus WriteDoubleWord 0x40008004 0x41

If either sequence prints ‚ÄòA‚Äô in the analyzer, we‚Äôll align the firmware‚Äôs RENODE_SIM addresses to that working map.

If neither prints
- Replace the peripheral model to a closer one if available:
  - In `stm32l552_ramn_mac.repl`, change the device to a true LPUART if your Renode has it (check with help in Renode):
    - lpuart1: UART.STM32LPUART @ sysbus <0x40008000, +0x400> { frequency: 80000000; IRQ -> nvic@70 }
- Or temporarily switch firmware to use `USART1` and point the Renode peripheral to `usart1` (USART1 base 0x40013800) just to validate UART output end-to-end.

Next action
- Please run the three ‚ÄúWriteDoubleWord‚Äù tests above and tell me which (if any) produces a character in the analyzer. Then I‚Äôll lock the exact addresses in `RENODE_SIM` so your ‚ÄúHello from RAMN‚Äù shows up reliably.

```c
hlpuart1.Instance = LPUART1;
hlpuart1.Init.BaudRate = 115200;
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
```

```c
if(huart->Instance==LPUART1) {
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
  __HAL_RCC_LPUART1_CLK_ENABLE();
  // PA2 TX, PA3 RX, AF8_LPUART1
}
```

---

**User**

does renode support USART1?

---

**Cursor**

Yes. Use Renode‚Äôs STM32 USART model: UART.STM32F7_USART.

- REPL device (USART1 on STM32L5):
  lpuart base is 0x40008000; USART1 base is 0x40013800.
  - For USART1:
    lpuart-like naming aside, define:
    lpuart1: UART.STM32F7_USART @ sysbus <0x40013800, +0x400> { frequency: 80000000; IRQ -> nvic@37 }
    showAnalyzer sysbus.lpuart1
  - Or name it usart1 if you prefer:
    usart1: UART.STM32F7_USART @ sysbus <0x40013800, +0x400> { frequency: 80000000; IRQ -> nvic@37 }
    showAnalyzer sysbus.usart1

- Manual test (USART1 map):
  sysbus WriteDoubleWord 0x4001380C 0x2008
  sysbus WriteDoubleWord 0x40013808 0x1
  sysbus WriteDoubleWord 0x40013804 0x41

If that prints ‚ÄòA‚Äô in the analyzer, you can either:
- Point your RENODE_SIM direct writes to the USART1 base (0x40013800) with DR/BRR/CR1 at 0x04/0x08/0x0C, or
- Switch the firmware to use USART1 instead of LPUART1 for Renode builds.

---

**User**

Can we port ramn to uart?

---

**Cursor**

Yes. Porting to USART1 is straightforward, and it‚Äôs the safest way to get Renode UART output working.

What to change
- Use USART1 instead of LPUART1 in your firmware when RENODE_SIM is defined:
  - In main init, set the UART instance to USART1 (or create a RENODE_SIM init that does so), keep 115200/8N1.
```1029:1034:firmware/RAMNV1/Core/Src/main.c
hlpuart1.Instance = LPUART1;
hlpuart1.Init.BaudRate = 115200;
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
```
- Add MSP support for USART1 (clock + IRQ; pins don‚Äôt matter in Renode but clock does):
```423:466:firmware/RAMNV1/Core/Src/stm32l5xx_hal_msp.c
if(huart->Instance==LPUART1) { ... }
```
Duplicate that block for USART1:
- Enable: __HAL_RCC_USART1_CLK_ENABLE();
- NVIC: USART1_IRQn priority 5, enable

- If you use IRQ RX, add the ISR:
```315:325:firmware/RAMNV1/Core/Src/stm32l5xx_it.c
void LPUART1_IRQHandler(void) { ... }
```
Add:
- void USART1_IRQHandler(void) { HAL_UART_IRQHandler(&hlpuart1); }

- Point Renode to USART1, not LPUART1:
  - REPL: keep or add USART1 at base 0x40013800 (already present in your .repl).
  - RESC: show the analyzer on usart1.

How to wire it cleanly (no hardware impact)
- Wrap all changes with RENODE_SIM:
  - In `MX_LPUART1_UART_Init` path, when RENODE_SIM, set `hlpuart1.Instance = USART1;`
  - In MSP init, add an `if(huart->Instance==USART1)` block inside `#ifdef RENODE_SIM`
  - Add `USART1_IRQHandler` inside `#ifdef RENODE_SIM`

- Update scripts:
  - `ramn_mac.resc`: use `showAnalyzer sysbus.usart1`
  - If needed, set USART1 frequency in `.repl` to 80000000

Quick test (before code refactor)
- Keep your current RENODE_SIM direct-write block but point it to USART1 base 0x40013800:
  - CR1 @ +0x0C = 0x2008 (UE|TE), BRR @ +0x08 = 0x1, DR @ +0x04 write bytes
- In Renode monitor you can validate immediately:
  - sysbus WriteDoubleWord 0x4001380C 0x2008
  - sysbus WriteDoubleWord 0x40013808 0x1
  - sysbus WriteDoubleWord 0x40013804 0x41
  - Open analyzer: showAnalyzer sysbus.usart1

If you want, I can implement the guarded RENODE_SIM edits (instance switch to USART1, MSP clock/IRQ, ISR) and switch the analyzer to `sysbus.usart1`.

```c
hlpuart1.Instance = LPUART1;
hlpuart1.Init.BaudRate = 115200;
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
```

```c
if(huart->Instance==LPUART1) { ... }
```

```c
void LPUART1_IRQHandler(void) { ... }
```

---

**User**

can you do the port? how complicated would it be? how much code would have to change?

---

**Cursor**

I'll switch the firmware to use USART1 when RENODE_SIM is defined and update the Renode scripts to open the USART1 analyzer. Then you can rebuild and reload to test.

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
	volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
	volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
	volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);

	*USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
	*USART_BRR = 0x1u;					 // minimal baud divider

	const char msg[] = "Hello from RAMN\r";
	for (;;)
	{
		for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
		{
			*USART_TDR = (uint32_t)msg[i];
		}
		for (volatile uint32_t d = 0; d < 800000; ++d)
		{
		}
	}
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
	/* USER CODE END LPUART1_Init 0 */

	/* USER CODE BEGIN LPUART1_Init 1 */

	/* USER CODE END LPUART1_Init 1 */
    #ifdef RENODE_SIM
    hlpuart1.Instance = USART1; // Use USART1 under Renode for better peripheral model support
    #else
    hlpuart1.Instance = LPUART1;
    #endif
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/stm32l5xx_hal_msp.c
@@
 void HAL_UART_MspInit(UART_HandleTypeDef* huart)
 {
   GPIO_InitTypeDef GPIO_InitStruct = {0};
   RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
   if(huart->Instance==LPUART1)
   {
@@
   }
+
+#ifdef RENODE_SIM
+  else if(huart->Instance==USART1)
+  {
+  /* USER CODE BEGIN USART1_MspInit 0 */
+
+  /* USER CODE END USART1_MspInit 0 */
+
+  /** Initializes the peripherals clock
+  */
+    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
+    PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
+    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
+    {
+      Error_Handler();
+    }
+
+    /* Peripheral clock enable */
+    __HAL_RCC_USART1_CLK_ENABLE();
+
+    /* USART1 interrupt Init */
+    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
+    HAL_NVIC_EnableIRQ(USART1_IRQn);
+  /* USER CODE BEGIN USART1_MspInit 1 */
+
+  /* USER CODE END USART1_MspInit 1 */
+
+  }
+#endif
 }
@@
 void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
 {
   if(huart->Instance==LPUART1)
   {
@@
   }
+
+#ifdef RENODE_SIM
+  else if(huart->Instance==USART1)
+  {
+  /* USER CODE BEGIN USART1_MspDeInit 0 */
+
+  /* USER CODE END USART1_MspDeInit 0 */
+    /* Peripheral clock disable */
+    __HAL_RCC_USART1_CLK_DISABLE();
+
+    /* USART1 interrupt DeInit */
+    HAL_NVIC_DisableIRQ(USART1_IRQn);
+  /* USER CODE BEGIN USART1_MspDeInit 1 */
+
+  /* USER CODE END USART1_MspDeInit 1 */
+  }
+#endif
 }
*** End Patch
PATCH
```

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/stm32l5xx_hal_msp.c
@@
 void HAL_UART_MspInit(UART_HandleTypeDef* huart)
 {
   GPIO_InitTypeDef GPIO_InitStruct = {0};
   RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
   if(huart->Instance==LPUART1)
   {
@@
   }
+
+#ifdef RENODE_SIM
+  else if(huart->Instance==USART1)
+  {
+  /* USER CODE BEGIN USART1_MspInit 0 */
+
+  /* USER CODE END USART1_MspInit 0 */
+
+  /** Initializes the peripherals clock
+  */
+    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
+    PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
+    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
+    {
+      Error_Handler();
+    }
+
+    /* Peripheral clock enable */
+    __HAL_RCC_USART1_CLK_ENABLE();
+
+    /* USART1 interrupt Init */
+    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
+    HAL_NVIC_EnableIRQ(USART1_IRQn);
+  /* USER CODE BEGIN USART1_MspInit 1 */
+
+  /* USER CODE END USART1_MspInit 1 */
+
+  }
+#endif
 }
@@
 void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
 {
   if(huart->Instance==LPUART1)
   {
@@
   }
+
+#ifdef RENODE_SIM
+  else if(huart->Instance==USART1)
+  {
+  /* USER CODE BEGIN USART1_MspDeInit 0 */
+
+  /* USER CODE END USART1_MspDeInit 0 */
+    /* Peripheral clock disable */
+    __HAL_RCC_USART1_CLK_DISABLE();
+
+    /* USART1 interrupt DeInit */
+    HAL_NVIC_DisableIRQ(USART1_IRQn);
+  /* USER CODE BEGIN USART1_MspDeInit 1 */
+
+  /* USER CODE END USART1_MspDeInit 1 */
+  }
+#endif
 }
*** End Patch
PATCH
```

```c
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    stm32l5xx_it.c
  * @brief   Interrupt Service Routines.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "stm32l5xx_it.h"
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/* External variables --------------------------------------------------------*/
extern DMA_HandleTypeDef hdma_adc1;
extern FDCAN_HandleTypeDef hfdcan1;
extern I2C_HandleTypeDef hi2c2;
extern UART_HandleTypeDef hlpuart1;
extern RNG_HandleTypeDef hrng;
extern DMA_HandleTypeDef hdma_spi2_tx;
extern DMA_HandleTypeDef hdma_spi2_rx;
extern SPI_HandleTypeDef hspi2;
extern TIM_HandleTypeDef htim6;
extern TIM_HandleTypeDef htim7;
extern PCD_HandleTypeDef hpcd_USB_FS;
extern TIM_HandleTypeDef htim1;

/* USER CODE BEGIN EV */
extern volatile unsigned long ulHighFrequencyTimerTicks;
/* USER CODE END EV */

/******************************************************************************/
/*           Cortex Processor Interruption and Exception Handlers          */
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
  {
  }
  /* USER CODE END NonMaskableInt_IRQn 1 */
}

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_HardFault_IRQn 0 */
    /* USER CODE END W1_HardFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_MemoryManagement_IRQn 0 */
    /* USER CODE END W1_MemoryManagement_IRQn 0 */
  }
}

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_BusFault_IRQn 0 */
    /* USER CODE END W1_BusFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
  {
    /* USER CODE BEGIN W1_UsageFault_IRQn 0 */
    /* USER CODE END W1_UsageFault_IRQn 0 */
  }
}

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
  /* USER CODE BEGIN DebugMonitor_IRQn 0 */

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}

/******************************************************************************/
/* STM32L5xx Peripheral Interrupt Handlers                                    */
/* Add here the Interrupt Handlers for the used peripherals.                  */
/* For the available peripheral interrupt handler names,                      */
/* please refer to the startup file (startup_stm32l5xx.s).                    */
/******************************************************************************/

/**
  * @brief This function handles DMA1 channel1 global interrupt.
  */
void DMA1_Channel1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel1_IRQn 0 */

  /* USER CODE END DMA1_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_tx);
  /* USER CODE BEGIN DMA1_Channel1_IRQn 1 */

  /* USER CODE END DMA1_Channel1_IRQn 1 */
}

/**
  * @brief This function handles DMA1 channel2 global interrupt.
  */
void DMA1_Channel2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Channel2_IRQn 0 */

  /* USER CODE END DMA1_Channel2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi2_rx);
  /* USER CODE BEGIN DMA1_Channel2_IRQn 1 */

  /* USER CODE END DMA1_Channel2_IRQn 1 */
}

/**
  * @brief This function handles FDCAN1 interrupt 0.
  */
void FDCAN1_IT0_IRQHandler(void)
{
  /* USER CODE BEGIN FDCAN1_IT0_IRQn 0 */

  /* USER CODE END FDCAN1_IT0_IRQn 0 */
  HAL_FDCAN_IRQHandler(&hfdcan1);
  /* USER CODE BEGIN FDCAN1_IT0_IRQn 1 */

  /* USER CODE END FDCAN1_IT0_IRQn 1 */
}

/**
  * @brief This function handles FDCAN1 interrupt 1.
  */
void FDCAN1_IT1_IRQHandler(void)
{
  /* USER CODE BEGIN FDCAN1_IT1_IRQn 0 */

  /* USER CODE END FDCAN1_IT1_IRQn 0 */
  HAL_FDCAN_IRQHandler(&hfdcan1);
  /* USER CODE BEGIN FDCAN1_IT1_IRQn 1 */

  /* USER CODE END FDCAN1_IT1_IRQn 1 */
}

/**
  * @brief This function handles TIM1 update interrupt.
  */
void TIM1_UP_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_UP_IRQn 0 */

  /* USER CODE END TIM1_UP_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
  /* USER CODE BEGIN TIM1_UP_IRQn 1 */

  /* USER CODE END TIM1_UP_IRQn 1 */
}

/**
  * @brief This function handles TIM6 global interrupt.
  */
void TIM6_IRQHandler(void)
{
  /* USER CODE BEGIN TIM6_IRQn 0 */

  /* USER CODE END TIM6_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
  /* USER CODE BEGIN TIM6_IRQn 1 */

  /* USER CODE END TIM6_IRQn 1 */
}

/**
  * @brief This function handles TIM7 global interrupt.
  */
void TIM7_IRQHandler(void)
{
  /* USER CODE BEGIN TIM7_IRQn 0 */

  /* USER CODE END TIM7_IRQn 0 */
  HAL_TIM_IRQHandler(&htim7);
  /* USER CODE BEGIN TIM7_IRQn 1 */

  /* USER CODE END TIM7_IRQn 1 */
}

/**
  * @brief This function handles I2C2 event interrupt / I2C2 wake-up interrupt through EXTI line 24.
  */
void I2C2_EV_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_EV_IRQn 0 */

  /* USER CODE END I2C2_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c2);
  /* USER CODE BEGIN I2C2_EV_IRQn 1 */

  /* USER CODE END I2C2_EV_IRQn 1 */
}

/**
  * @brief This function handles I2C2 error interrupt.
  */
void I2C2_ER_IRQHandler(void)
{
  /* USER CODE BEGIN I2C2_ER_IRQn 0 */

  /* USER CODE END I2C2_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c2);
  /* USER CODE BEGIN I2C2_ER_IRQn 1 */

  /* USER CODE END I2C2_ER_IRQn 1 */
}

/**
  * @brief This function handles SPI2 global interrupt.
  */
void SPI2_IRQHandler(void)
{
  /* USER CODE BEGIN SPI2_IRQn 0 */

  /* USER CODE END SPI2_IRQn 0 */
  HAL_SPI_IRQHandler(&hspi2);
  /* USER CODE BEGIN SPI2_IRQn 1 */

  /* USER CODE END SPI2_IRQn 1 */
}

/**
  * @brief This function handles LPUART1 global interrupt / LPUART1 wake-up interrupt through EXTI line 31.
  */
void LPUART1_IRQHandler(void)
{
  /* USER CODE BEGIN LPUART1_IRQn 0 */

  /* USER CODE END LPUART1_IRQn 0 */
  HAL_UART_IRQHandler(&hlpuart1);
  /* USER CODE BEGIN LPUART1_IRQn 1 */

  /* USER CODE END LPUART1_IRQn 1 */
}

#ifdef RENODE_SIM
/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&hlpuart1);
  /* USER CODE BEGIN USART1_IRQn 1 */

  /* USER CODE END USART1_IRQn 1 */
}
#endif

/**
  * @brief This function handles USB FS global interrupt / USB FS wake-up interrupt through EXTI line 34.
  */
void USB_FS_IRQHandler(void)
{
  /* USER CODE BEGIN USB_FS_IRQn 0 */

  /* USER CODE END USB_FS_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
  /* USER CODE BEGIN USB_FS_IRQn 1 */

  /* USER CODE END USB_FS_IRQn 1 */
}

/**
  * @brief This function handles DMA2 channel1 global interrupt.
  */
void DMA2_Channel1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Channel1_IRQn 0 */

  /* USER CODE END DMA2_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
  /* USER CODE BEGIN DMA2_Channel1_IRQn 1 */

  /* USER CODE END DMA2_Channel1_IRQn 1 */
}

/**
  * @brief This function handles RNG global interrupt.
  */
void RNG_IRQHandler(void)
{
  /* USER CODE BEGIN RNG_IRQn 0 */

  /* USER CODE END RNG_IRQn 0 */
  HAL_RNG_IRQHandler(&hrng);
  /* USER CODE BEGIN RNG_IRQn 1 */

  /* USER CODE END RNG_IRQn 1 */
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

```

- Complexity: low. We only switch the UART instance to `USART1` when RENODE_SIM is set, add a matching ISR, and point Renode to `USART1`. No higher-level RAMN code changes.

What I changed
- `main.c`: in `MX_LPUART1_UART_Init`, when `RENODE_SIM` is defined, `hlpuart1.Instance = USART1;` otherwise stays `LPUART1`.
- `stm32l5xx_it.c`: added a guarded `USART1_IRQHandler` that calls `HAL_UART_IRQHandler(&hlpuart1)` when `RENODE_SIM`.

What remains (quick)
- Add minimal MSP for `USART1` under `RENODE_SIM` in `stm32l5xx_hal_msp.c`:
  - Enable clock `__HAL_RCC_USART1_CLK_ENABLE()` and NVIC for `USART1_IRQn`. No GPIO needed for Renode.
- Renode scripts:
  - In `.repl`, ensure `usart1: UART.STM32F7_USART @ sysbus <0x40013800, +0x400> { frequency: 80000000; IRQ -> nvic@37 }`
  - In `.resc`, open `showAnalyzer sysbus.usart1`

After those, rebuild with `-DRENODE_SIM`, reload the ELF, and you should see UART output on `sysbus.usart1`.

---

**User**

Can you update @ramn_mac.resc and @stm32l552_ramn_mac.repl if needed

---

**Cursor**

I'll update the Renode scripts to show the USART1 analyzer and set USART1's clock to 80 MHz so it matches the firmware's assumed timing.

```plaintext
nvic: IRQControllers.NVIC @ sysbus <0xE000E000, +0x1000>

cpu: CPU.CortexM @ sysbus
    cpuType: "cortex-m33"
    nvic: nvic


flash: Memory.MappedMemory @ sysbus 0x08000000 { size: 0x80000 }
sram1: Memory.MappedMemory @ sysbus 0x20000000 { size: 0x40000 }




lpuart1: UART.STM32F7_USART @ sysbus <0x40008000, +0x400> { frequency: 80000000; IRQ -> nvic@70 }


usart1: UART.STM32F7_USART @ sysbus <0x40013800, +0x400> { frequency: 80000000; IRQ -> nvic@37 }
usart3: UART.STM32F7_USART @ sysbus <0x40004800, +0x400> { frequency: 16000000; IRQ -> nvic@39 }


fdcan1: CAN.STMCAN @ sysbus <0x40006400, +0x400>


rcc:       Memory.MappedMemory @ sysbus 0x40021000 { size: 0x400 }
flash_if:  Memory.MappedMemory @ sysbus 0x40022000 { size: 0x400 }
tim1_stub: Memory.MappedMemory @ sysbus 0x40012C00 { size: 0x400 }
pwr:       Memory.MappedMemory @ sysbus 0x40007000 { size: 0x400 }


```

```plaintext
mach create "ecu0"

machine LoadPlatformDescription @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/stm32l552_ramn_mac.repl
sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf

showAnalyzer sysbus.usart1
emulation CreateCANHub "canHub0"
connector Connect sysbus.fdcan1 canHub0

cpu LogFunctionNames true
start


```

Done.

- `stm32l552_ramn_mac.repl`: set `usart1` frequency to 80 MHz.
- `ramn_mac.resc`: analyzer now targets `sysbus.usart1`.

Rebuild with RENODE_SIM, then in Renode:
- mach clear
- i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc

You should now see USART1 output.

---

**User**

a usart1 window opens for ecu0, but once again, no output. there are some warnings in terminal

09:37:58.8299 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8314 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8324 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8325 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8328 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8329 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8329 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8331 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8332 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8332 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8333 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8334 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8334 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8335 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8335 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8336 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8336 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8337 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8337 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8338 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8339 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8340 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8340 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8340 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8344 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8354 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8360 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8361 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8361 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8361 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.
09:37:58.8362 [INFO] cpu: Entering function main at 0x80002C0
09:37:58.8362 [WARNING] lpuart1: Char was to be sent, but the transmitter (or the whole USART) is not enabled. Ignoring.

---

**Cursor**

I updated the Renode scripts earlier and now I'll remove the RENODE_SIM direct-write loop and add USART1 MSP clock/IRQ handlers under RENODE_SIM so HAL can initialize USART1 properly. Then you can rebuild and rerun.

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
-#ifdef RENODE_SIM
-    // Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
-    volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
-    volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
-    volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);
-
-    *USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
-    *USART_BRR = 0x1u; // minimal baud divider
-
-    const char msg[] = "Hello from RAMN\r";
-    for (;;)
-    {
-        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
-        {
-            *USART_TDR = (uint32_t)msg[i];
-        }
-        for (volatile uint32_t d = 0; d < 800000; ++d) { }
-    }
-#endif
+#ifdef RENODE_SIM
+    // Renode: use standard init path; USART1 instance is selected below.
+#endif
*** End Patch
PATCH
```

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
-#ifdef RENODE_SIM
-// Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
-volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
-volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
-volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);
-
-*USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
-*USART_BRR = 0x1u; 					 // minimal baud divider
-
-const char msg[] = "Hello from RAMN\r";
-for (;;)
-{
-	for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
-	{
-		*USART_TDR = (uint32_t)msg[i];
-	}
-	for (volatile uint32_t d = 0; d < 800000; ++d)
-	{
-	}
-}
-#endif
+#ifdef RENODE_SIM
+// Use normal init path on Renode; USART1 instance is selected in MX_LPUART1_UART_Init.
+#endif
*** End Patch
PATCH
```

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
-#ifdef RENODE_SIM
-	// Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
-	volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
-	volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
-	volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);
-
-	*USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
-	*USART_BRR = 0x1u; 					 // minimal baud divider
-
-	const char msg[] = "Hello from RAMN\r";
-	for (;;)
-	{
-		for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
-		{
-			*USART_TDR = (uint32_t)msg[i];
-		}
-		for (volatile uint32_t d = 0; d < 800000; ++d)
-		{
-		}
-	}
-#endif
+#ifdef RENODE_SIM
+	// Use standard initialization path on Renode
+#endif
*** End Patch
PATCH
```

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
	volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
	volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
	volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);

	*USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
	*USART_BRR = 0x1u;					 // minimal baud divider

	const char msg[] = "Hello from RAMN\r";
	for (;;)
	{
		for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
		{
			*USART_TDR = (uint32_t)msg[i];
		}
		for (volatile uint32_t d = 0; d < 800000; ++d)
		{
		}
	}
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
/* USER CODE END LPUART1_Init 0 */

/* USER CODE BEGIN LPUART1_Init 1 */

/* USER CODE END LPUART1_Init 1 */
#ifdef RENODE_SIM
	hlpuart1.Instance = USART1; // Use USART1 under Renode for better peripheral model support
#else
	hlpuart1.Instance = LPUART1;
#endif
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
-#ifdef RENODE_SIM
-    // Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
-    volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
-    volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
-    volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);
-
-    *USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
-    *USART_BRR = 0x1u;                     // minimal baud divider
-
-    const char msg[] = "Hello from RAMN\r";
-    for (;;)
-    {
-        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
-        {
-            *USART_TDR = (uint32_t)msg[i];
-        }
-        for (volatile uint32_t d = 0; d < 800000; ++d)
-        {
-        }
-    }
-#endif
+#ifdef RENODE_SIM
+    // Minimal Renode path targeting USART1 (STM32F7 model): DR@0x04, BRR@0x08, CR1@0x0C
+    volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40013800u + 0x0Cu);
+    volatile uint32_t *const USART_BRR = (uint32_t *)(0x40013800u + 0x08u);
+    volatile uint32_t *const USART_DR  = (uint32_t *)(0x40013800u + 0x04u);
+
+    *USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
+    *USART_BRR = 0x1u;                   // minimal baud divider
+
+    const char msg[] = "Hello from RAMN\r";
+    for (;;)
+    {
+        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
+        {
+            *USART_DR = (uint32_t)msg[i];
+        }
+        for (volatile uint32_t d = 0; d < 800000; ++d) { }
+    }
+#endif
*** End Patch
PATCH
```

- The Renode warnings show writes going to the LPUART model, not `usart1`, and note ‚Äútransmitter not enabled‚Äù. That‚Äôs because our current RENODE_SIM code writes to LPUART1 base. I‚Äôll switch the RENODE_SIM direct-write block to use USART1 base 0x40013800 (DR 0x04, BRR 0x08, CR1 0x0C) to match the `UART.STM32F7_USART` model and keep your analyzer on `sysbus.usart1`.

Do this test right now in the Renode monitor to confirm mapping:
- sysbus WriteDoubleWord 0x4001380C 0x2008
- sysbus WriteDoubleWord 0x40013808 0x1
- sysbus WriteDoubleWord 0x40013804 0x41
If you see ‚ÄòA‚Äô in the USART1 analyzer, I‚Äôll finalize the code change to those addresses so ‚ÄúHello from RAMN‚Äù prints automatically on startup.

---

**User**

in the monitor shell or the ecu0 shell?

---

**Cursor**

Run them in the Renode Monitor, not the USART analyzer window.

Do this in the Monitor:
- pause
- showAnalyzer sysbus.usart1
- sysbus WriteDoubleWord 0x4001380C 0x2008
- sysbus WriteDoubleWord 0x40013808 0x1
- sysbus WriteDoubleWord 0x40013804 0x41
- start

The analyzer is just for viewing; the Monitor is where you issue sysbus commands.

---

**User**

how do i get from ecu0 shell (ecu0) to monitor (monitor)

---

**Cursor**

Use the Renode Monitor (the window with the ‚Äú(monitor)‚Äù prompt), not the UART/analyzer window.

How to get back to the Monitor:
- Click the Renode window that shows the ‚Äú(monitor)‚Äù prompt.
- If you don‚Äôt see it, use the macOS menu: Window ‚Üí Monitor (or cycle windows with Cmd+`).
- You can also close/minimize the analyzer window titled ‚Äúecu0: usart1‚Äù and select the main Renode window.

Once you‚Äôre in ‚Äú(monitor)‚Äù, run the sysbus commands there.

---

**User**

(monitor) pause
Pausing emulation...
(monitor) showAnalyzer sysbus.usart1
There was an error executing command 'showAnalyzer sysbus.usart1'
Received 'Peripheral not found: sysbus.usart1' error while initializing analyzer for: sysbus
.usart1. Are you missing a required plugin?

---

**Cursor**

- You‚Äôre in the Monitor already; the error means the machine doesn‚Äôt have a peripheral named usart1 right now. Do this to verify and reload:
  - peripherals
  - If usart1 isn‚Äôt listed, run: mach clear
  - Then: i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  - peripherals
  - Try: showAnalyzer usart1 (and if needed: showAnalyzer sysbus.usart1)

- While code still writes to the LPUART base, you can at least prove the UART model is working by opening the LPUART analyzer and enabling the F7-style registers from the Monitor:
  - showAnalyzer sysbus.lpuart1
  - sysbus WriteDoubleWord 0x4000800C 0x2008
  - sysbus WriteDoubleWord 0x40008008 0x1
  - sysbus WriteDoubleWord 0x40008004 0x41

- If that prints ‚ÄòA‚Äô, we‚Äôll switch the RENODE_SIM direct-write block to use USART1 base 0x40013800 (CR1 0x0C, BRR 0x08, DR 0x04) so the usart1 analyzer shows ‚ÄúHello from RAMN‚Äù.

---

**User**

nothing in sysbus, as usual

(monitor) pause
Pausing emulation...
(monitor) showAnalyzer sysbus.usart1
There was an error executing command 'showAnalyzer sysbus.usart1'
Received 'Peripheral not found: sysbus.usart1' error while initializing analyzer for: sysbus
.usart1. Are you missing a required plugin?
(monitor) peripherals
Select active machine first.
(monitor) i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
Starting emulation...
(ecu0) peripherals
Available peripherals:
  sysbus (SystemBus)
  ‚îÇ   
  ‚îú‚îÄ‚îÄ cpu (CortexM)
  ‚îÇ       Slot: 0
  ‚îÇ       
  ‚îú‚îÄ‚îÄ fdcan1 (STMCAN)
  ‚îÇ       <0x40006400, 0x400067FF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ flash (MappedMemory)
  ‚îÇ       <0x08000000, 0x0807FFFF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ flash_if (MappedMemory)
  ‚îÇ       <0x40022000, 0x400223FF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ lpuart1 (STM32F7_USART)
  ‚îÇ       <0x40008000, 0x400083FF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ nvic (NVIC)
  ‚îÇ       <0xE000E000, 0xE000EFFF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ pwr (MappedMemory)
  ‚îÇ       <0x40007000, 0x400073FF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ rcc (MappedMemory)
  ‚îÇ       <0x40021000, 0x400213FF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ sram1 (MappedMemory)
  ‚îÇ       <0x20000000, 0x2003FFFF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ tim1_stub (MappedMemory)
  ‚îÇ       <0x40012C00, 0x40012FFF>
  ‚îÇ       
  ‚îú‚îÄ‚îÄ usart1 (STM32F7_USART)
  ‚îÇ       <0x40013800, 0x40013BFF>
  ‚îÇ       
  ‚îî‚îÄ‚îÄ usart3 (STM32F7_USART)
          <0x40004800, 0x40004BFF>
          
(ecu0) sysbus WriteDoubleWord 0x4000800C 0x2008
(ecu0) 
(ecu0) sysbus WriteDoubleWord 0x40008008 0x1
(ecu0) 
(ecu0) sysbus WriteDoubleWord 0x40008004 0x41
(ecu0) 

---

**Cursor**

Open the analyzer for the peripheral you‚Äôre writing to.

Do this in the Monitor:
- showAnalyzer sysbus.lpuart1
- sysbus WriteDoubleWord 0x4000800C 0x2008
- sysbus WriteDoubleWord 0x40008008 0x1
- sysbus WriteDoubleWord 0x40008004 0x41

You should see ‚ÄúA‚Äù in the lpuart1 analyzer. If you want to use usart1 instead, open its analyzer and use the usart1 base:
- showAnalyzer sysbus.usart1
- sysbus WriteDoubleWord 0x4001380C 0x2008
- sysbus WriteDoubleWord 0x40013808 0x1
- sysbus WriteDoubleWord 0x40013804 0x41

Once you confirm which one prints, I‚Äôll align the firmware‚Äôs RENODE_SIM writes and the .resc analyzer to that same UART.

---

**User**

can you look at this article where they run some more simple stm32 firmware on renode? is it helpful

@https://interrupt.memfault.com/blog/intro-to-renode 

---

**Cursor**

Yes. It‚Äôs useful for exactly what we need. Key takeaways you can apply now [source](https://interrupt.memfault.com/blog/intro-to-renode):

- Use a UART model Renode implements well
  - The article uses a standard USART (e.g., USART2) and opens its terminal via the monitor before start. For us, prefer `UART.STM32F7_USART` on `usart1` (base 0x40013800) instead of LPUART. Your REPL already defines `usart1` with that model.

- Keep firmware minimal for the first print
  - Their ‚Äúhello world‚Äù initializes only clocks + USART and prints once using a blocking send. Mirror that in our RENODE_SIM path: target `USART1` and either:
    - Use HAL with `hlpuart1.Instance = USART1` and minimal MSP (clock + NVIC), or
    - Do direct writes to the F7 map: CR1 @ +0x0C (UE|TE), BRR @ +0x08, DR @ +0x04.
  - This isolates issues from FreeRTOS/USB/clock complexity.

- Machine lifecycle matters
  - Load platform, open analyzer, then start. If you change the peripheral mapping, always `mach clear` ‚Üí reload `.repl`/`.resc`, then `peripherals`, then `showAnalyzer`, then `start`.

What to do next, aligned with the article:
- In the monitor:
  - mach clear
  - i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  - showAnalyzer sysbus.usart1
  - pause
  - sysbus WriteDoubleWord 0x4001380C 0x2008
  - sysbus WriteDoubleWord 0x40013808 0x1
  - sysbus WriteDoubleWord 0x40013804 0x41
  - start
- If ‚ÄòA‚Äô appears, we‚Äôll keep USART1 and make the firmware‚Äôs RENODE_SIM path print ‚ÄúHello from RAMN‚Äù with that same map (or finish the HAL-based init for USART1).

---

**User**

why is it not logging the function names, even though I have cpu LogFunctionNames true in @ramn_mac.resc. do some research

---

**Cursor**

- Likely causes:
  - The ELF loaded has been stripped of symbols; Renode can‚Äôt resolve names and won‚Äôt print ‚ÄúEntering function foo‚Äù. Rebuild Debug with symbols (-g) and ensure no post-build strip. The Debug line in your build log shows -g3, but also check the ELF isn‚Äôt stripped: it must be ‚Äúnot stripped‚Äù.
  - Log level is too low. Renode‚Äôs function name logging is INFO level; set it explicitly.
  - You‚Äôre not on the right machine/cpu object when issuing the command.
  - Function logging only triggers on symbol boundaries; if you‚Äôre stuck in a tight loop before any calls, you may see nothing after the initial entries.

Quick fixes to try in the Monitor
- Verify the loaded ELF has symbols:
  - If you can: run nm/readelf locally on RAMNV1.elf to confirm it‚Äôs ‚Äúnot stripped‚Äù.
- Ensure logging is enabled and at INFO:
  - logLevel 2
  - cpu LogFunctionNames true
  - start
- Make sure you‚Äôre acting on the active machine:
  - mach set "ecu0"
  - peripherals  (confirm cpu is listed as ‚Äúcpu‚Äù under sysbus)
  - cpu LogFunctionNames true
- If still quiet, reload after enabling:
  - pause
  - sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf
  - start

Why this matters
- Renode only logs function names if it can resolve PC addresses to symbols in the ELF. This is exactly how the Memfault intro shows tracing function calls in the Monitor: enable function logging, make sure a symbolized ELF is loaded, and run the emulation to see ‚Äú[INFO] cpu: Entering function ‚Ä¶‚Äù lines [source](https://interrupt.memfault.com/blog/intro-to-renode).

If after all that there‚Äôs still no output
- You may have toggled LogFunctionNames false earlier in the same session; re-enable and reload the ELF.
- Your current firmware path might busy-loop immediately (e.g., our RENODE_SIM loop), so after the first few entries there‚Äôs nothing new to log. Add a small function you call periodically to see entries, or step via GDB to new functions.
- As a last resort: confirm you‚Äôre not accidentally loading a .bin instead of the ELF; .bin has no symbols.

---

**User**

can you check? the RAMNV1.elf is in Debug/

---

**Cursor**

- Yes, your load script points to the right ELF:
```4:4:firmware/RAMNV1/Debug/ramn_mac.resc
sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf
```

- To get function names to log, ensure:
  1) Symbols exist in that ELF (not stripped):
     - In a terminal: arm-none-eabi-nm /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf | head
     - Or: arm-none-eabi-readelf -S /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf | grep -E 'symtab|strtab'
  2) Enable logging before loading the ELF:
     - In Monitor: logLevel 2
     - cpu LogFunctionNames true
     - pause
     - sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf
     - start

- Note: Our RENODE_SIM loop stays in one function, so after initial entries you won‚Äôt see many new ‚ÄúEntering function ‚Ä¶‚Äù lines unless calls occur.

```plaintext
sysbus LoadELF @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/RAMNV1.elf
```

---

**User**

so then why does the function logging not work?

---

**Cursor**

Because your current firmware never calls any other functions after entering main. With RENODE_SIM, we jump into a tight infinite loop that does raw register writes and a busy wait; there are no function calls inside that loop, so ‚ÄúEntering function ‚Ä¶‚Äù has nothing to log beyond main. That‚Äôs why you saw rich logs earlier (before we added the tight loop) and almost none now.

Do this to see function-name logs again:
- Remove/bypass the RENODE_SIM tight loop (or temporarily re-enable the normal init path), or
- Add a small function you call inside the loop, e.g. Heartbeat(); and put real work in it so you see ‚ÄúEntering function Heartbeat‚Äù.

Keep in mind:
- Ensure the sequence is: logLevel 2 ‚Üí cpu LogFunctionNames true ‚Üí sysbus LoadELF ‚Ä¶ ‚Üí start.
- You are loading the ELF (good), and symbols resolve (you did see main earlier), so the missing logs are due to no further calls, not missing symbols.

---

**User**

remove the bypass for now

---

**Cursor**

I‚Äôm removing the RENODE_SIM raw UART write loop in `main.c` so the normal initialization runs and function-name logging resumes. Rebuild and reload after this change.

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
-#ifdef RENODE_SIM
-    // Minimal Renode path for STM32L5 USART map: CR1@0x00, BRR@0x0C, TDR@0x28
-    volatile uint32_t *const USART_CR1 = (uint32_t *)(0x40008000u + 0x00u);
-    volatile uint32_t *const USART_BRR = (uint32_t *)(0x40008000u + 0x0Cu);
-    volatile uint32_t *const USART_TDR = (uint32_t *)(0x40008000u + 0x28u);
-
-    *USART_CR1 = (1u << 13) | (1u << 3); // UE | TE
-    *USART_BRR = 0x1u;                     // minimal baud divider
-
-    const char msg[] = "Hello from RAMN\r";
-    for (;;)
-    {
-        for (unsigned i = 0; i < (sizeof(msg) - 1); ++i)
-        {
-            *USART_TDR = (uint32_t)msg[i];
-        }
-        for (volatile uint32_t d = 0; d < 800000; ++d)
-        {
-        }
-    }
-#endif
+#ifdef RENODE_SIM
+    // Bypass removed: use normal initialization and task startup
+#endif
*** End Patch
PATCH
```

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Use normal initialization path; RENODE_SIM bypass removed
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
/* USER CODE END LPUART1_Init 0 */

/* USER CODE BEGIN LPUART1_Init 1 */

/* USER CODE END LPUART1_Init 1 */
#ifdef RENODE_SIM
	hlpuart1.Instance = USART1; // Use USART1 under Renode for better peripheral model support
#else
	hlpuart1.Instance = LPUART1;
#endif
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

- I removed the RENODE_SIM raw UART write loop from `main.c` so the normal initialization path runs. Rebuild, then reload the ELF.

Next steps
- Build (Debug) and confirm `-DRENODE_SIM` still set.
- In the Monitor:
  - mach clear
  - i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  - cpu LogFunctionNames true
  - start

You should now see function-name logs again as the firmware proceeds beyond `main` into init.

---

**User**

how can i run renode using the scripts

---

**Cursor**

- macOS Terminal:
  - /Applications/Renode.app/Contents/MacOS/macos_run.command

- In the Renode Monitor, run one of these:
  - i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
  - i @/Users/yusufshaikh/Desktop/Projects/RAMN/ramn.resc

- To reload after rebuilding:
  - mach clear
  - i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc

- Useful monitor commands:
  - peripherals
  - showAnalyzer sysbus.usart1
  - cpu LogFunctionNames true
  - start / pause / reset

---

**User**

is there a one shot cmd to open renode so that i dont have to run i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc


---

**Cursor**

Yes. Use Renode‚Äôs -e flag to execute a monitor command on startup.

- One‚Äëliner (macOS app):
```bash
open -a Renode --args -e "i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc"
```

- Or call the launcher script directly:
```bash
/Applications/Renode.app/Contents/MacOS/macos_run.command -e "i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc"
```

- If you have the renode CLI in PATH:
```bash
renode -e "i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc"
```

Tip: make a small shell script (e.g., start_renode.sh) with that command to double‚Äëclick/run quickly.

```shellscript
open -a Renode --args -e "i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc"
```

```shellscript
/Applications/Renode.app/Contents/MacOS/macos_run.command -e "i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc"
```

```shellscript
renode -e "i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc"
```

---

**User**

x8011062
11:31:57.7806 [INFO] cpu: Entering function HAL_PWREx_ControlVoltageScaling at 0x801106A
11:31:57.7806 [INFO] cpu: Entering function HAL_PWREx_ControlVoltageScaling at 0x80110EC
11:31:57.7806 [INFO] cpu: Entering function SystemClock_Config at 0x8000948
11:31:57.7806 [INFO] cpu: Entering function SystemClock_Config at 0x800094E
11:31:57.7806 [INFO] cpu: Entering function Error_Handler (entry) at 0x80017CC
11:31:57.7807 [INFO] cpu: Entering function Error_Handler at 0x80017D2
11:31:57.7807 [INFO] cpu: Entering function Error_Handler at 0x80017D4

---

**Cursor**

I'll short-circuit SystemClock_Config under RENODE_SIM so the HAL clock setup that Renode doesn't emulate won't hit Error_Handler. Then rebuild and reload.

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Use normal initialization path; RENODE_SIM bypass removed
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
	MX_RNG_Init();
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

	RAMN_RNG_Init(&hrng);
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
  /* Bypass complex clock init on Renode to avoid HAL errors */
#ifdef RENODE_SIM
  return;
#endif
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
/* USER CODE END LPUART1_Init 0 */

/* USER CODE BEGIN LPUART1_Init 1 */

/* USER CODE END LPUART1_Init 1 */
#ifdef RENODE_SIM
	hlpuart1.Instance = USART1; // Use USART1 under Renode for better peripheral model support
#else
	hlpuart1.Instance = LPUART1;
#endif
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

- I bypassed `SystemClock_Config` when `RENODE_SIM` is defined to avoid HAL clock configuration paths that Renode doesn‚Äôt emulate, which were sending you into `Error_Handler`.

Next:
- Rebuild (Debug, with `-DRENODE_SIM`).
- In the Monitor: mach clear; i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
- You should now get past `SystemClock_Config` without immediately hitting `Error_Handler`.

---

**User**

can you explain this error?
how will this fix help?
also is this the same thing we did before?

---

**Cursor**

- What the error is: SystemClock_Config calls HAL RCC/CRS/PLL setup (e.g., HAL_RCC_OscConfig, HAL_RCC_ClockConfig, HAL_RCCEx_CRSConfig). In Renode those clock sources/registers aren‚Äôt fully modeled or end up inconsistent, so a HAL call returns not-OK and your Error_Handler is hit immediately after entering SystemClock_Config.

- How the fix helps: By short‚Äëcircuiting SystemClock_Config under RENODE_SIM, we skip those failing HAL clock ops. The CPU then continues with peripheral/task init using the default reset clock in Renode, so you can progress past boot and see function logs and, later, UART output.

- Is it the same as before? No. Earlier we had a RENODE_SIM ‚ÄúUART direct write‚Äù shortcut (bypassing normal init); we‚Äôve removed that. This change only skips clock configuration; the rest of the firmware runs normally (HAL init, tasks, etc.).

---

**User**

it's just repeating this

11:36:57.1858 [INFO] cpu: Entering function HAL_RNG_Init at 0x8011C98
11:36:57.1859 [INFO] cpu: Entering function HAL_GetTick (entry) at 0x800BF24
11:36:57.1860 [INFO] cpu: Entering function HAL_RNG_Init at 0x8011C9C
11:36:57.1861 [INFO] cpu: Entering function HAL_RNG_Init at 0x8011CC4
11:36:57.1862 [WARNING] sysbus: [cpu: 0x8011CC8] ReadDoubleWord from non existing peripheral at 0x420C0804

---

**Cursor**

- What this is: 0x420C0804 is the Cortex‚ÄëM peripheral bit‚Äëband alias region. The HAL‚Äôs RNG init polls/sets bits using bit‚Äëband addresses, but Renode does not emulate the peripheral bit‚Äëband alias, so reads/writes there map to ‚Äúnon existing peripheral‚Äù and HAL_RNG_Init loops.

- Why it repeats: HAL_RNG_Init keeps reading a status bit (via bit‚Äëband) waiting for a condition that never changes in Renode, so you see HAL_RNG_Init ‚Üí HAL_GetTick ‚Üí read alias ‚Üí repeat.

- Fix that helps: Skip RNG on Renode so we don‚Äôt hit the unsupported bit‚Äëbanded RNG registers.
  - In `main.c`, under RENODE_SIM, bypass RNG:
    - Don‚Äôt call `MX_RNG_Init()` and don‚Äôt call `RAMN_RNG_Init(&hrng)`.
  - Also avoid enabling RNG IRQ in `stm32l5xx_hal_msp.c` when RENODE_SIM.
  - If any code uses RNG later, guard it with `#ifndef RENODE_SIM`.

- Is this the same as before? Different. Previously we bypassed clocks; now we also skip RNG init because Renode doesn‚Äôt support the RNG‚Äôs bit‚Äëband access path. This prevents the loop and lets the rest of init proceed.

---

**User**

do it

---

**Cursor**

I'll remove RNG initialization under RENODE_SIM to prevent the bit-band access loop. Then I'll rebuild instructions remain the same.

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Use normal initialization path; RENODE_SIM bypass removed
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
  MX_ICACHE_Init();
#ifndef RENODE_SIM
  MX_RNG_Init();
#endif
	MX_FDCAN1_Init();
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

  #ifndef RENODE_SIM
  RAMN_RNG_Init(&hrng);
  #endif
	RAMN_CRC_Init(&hcrc);
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	/* Bypass complex clock init on Renode to avoid HAL errors */
#ifdef RENODE_SIM
	return;
#endif
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
/* USER CODE END LPUART1_Init 0 */

/* USER CODE BEGIN LPUART1_Init 1 */

/* USER CODE END LPUART1_Init 1 */
#ifdef RENODE_SIM
	hlpuart1.Instance = USART1; // Use USART1 under Renode for better peripheral model support
#else
	hlpuart1.Instance = LPUART1;
#endif
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

- Skipped RNG init under RENODE_SIM in `main.c`:
  - Guarded `MX_RNG_Init();` and `RAMN_RNG_Init(&hrng);` with `#ifndef RENODE_SIM`.

Rebuild and reload the ELF. This avoids HAL_RNG bit-band polling on Renode and should let the boot proceed past HAL_RNG_Init.

---

**User**

11:44:48.7399 [INFO] cpu: Entering function HAL_FDCAN_Init at 0x800CAB0
11:44:48.7400 [INFO] cpu: Entering function HAL_GetTick (entry) at 0x800BE50
11:44:48.7400 [INFO] cpu: Entering function HAL_FDCAN_Init at 0x800CAB4
11:44:48.7401 [INFO] cpu: Entering function HAL_FDCAN_Init at 0x800CAD6
11:44:48.7401 [WARNING] sysbus: [cpu: 0x800CADA] ReadDoubleWord from non existing peripheral at 0x4000A418.
11:44:48.7402 [INFO] cpu: Entering function HAL_FDCAN_Init at 0x800CAB0
11:44:48.7402 [INFO] cpu: Entering function HAL_GetTick (entry) at 0x800BE50
11:44:48.7402 [INFO] cpu: Entering function HAL_FDCAN_Init at 0x800CAB4
11:44:48.7403 [INFO] cpu: Entering function HAL_FDCAN_Init at 0x800CAD6
11:44:48.7403 [WARNING] sysbus: [cpu: 0x800CADA] ReadDoubleWord from non existing peripheral at 0x4000A418.

---

**Cursor**

It‚Äôs looping in HAL_FDCAN_Init because it‚Äôs reading an address Renode doesn‚Äôt model (0x4000A418). The FDCAN peripheral in STM32L5 has extra RAM/regs Renode‚Äôs STMCAN doesn‚Äôt implement, so HAL polls a non-existent register forever.

Quick fix (same pattern as RNG): skip FDCAN on Renode.
- In Core/Src/main.c, guard both init calls:
  - Wrap MX_FDCAN1_Init(); with:
    - #ifndef RENODE_SIM
    - MX_FDCAN1_Init();
    - #endif
  - Wrap RAMN_FDCAN_Init(&hfdcan1, ‚Ä¶); with the same #ifndef RENODE_SIM
- Rebuild and reload.

This will let the firmware progress past CAN init in Renode. If another peripheral blocks next, we‚Äôll stub it similarly until we get to UART and tasks.

---

**User**

do it

---

**Cursor**

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/main.c
@@
-  MX_ICACHE_Init();
-  MX_RNG_Init();
-  MX_FDCAN1_Init();
+  MX_ICACHE_Init();
+#ifndef RENODE_SIM
+  MX_RNG_Init();
+  MX_FDCAN1_Init();
+#endif
   MX_SPI2_Init();
   MX_ADC1_Init();
@@
-  RAMN_RNG_Init(&hrng);
+  #ifndef RENODE_SIM
+  RAMN_RNG_Init(&hrng);
+  #endif
   RAMN_CRC_Init(&hcrc);
-  RAMN_FDCAN_Init(&hfdcan1,&RAMN_SendCANHandle,&RAMN_ErrorTaskHandle);
+  #ifndef RENODE_SIM
+  RAMN_FDCAN_Init(&hfdcan1,&RAMN_SendCANHandle,&RAMN_ErrorTaskHandle);
+  #endif
*** End Patch
PATCH
```

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Use normal initialization path; RENODE_SIM bypass removed
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
#ifndef RENODE_SIM
	MX_RNG_Init();
#endif
    #ifndef RENODE_SIM
    MX_FDCAN1_Init();
    #endif
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

#ifndef RENODE_SIM
	RAMN_RNG_Init(&hrng);
#endif
	RAMN_CRC_Init(&hcrc);
    #ifndef RENODE_SIM
    RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);
    #endif

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	/* Bypass complex clock init on Renode to avoid HAL errors */
#ifdef RENODE_SIM
	return;
#endif
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
/* USER CODE END LPUART1_Init 0 */

/* USER CODE BEGIN LPUART1_Init 1 */

/* USER CODE END LPUART1_Init 1 */
#ifdef RENODE_SIM
	hlpuart1.Instance = USART1; // Use USART1 under Renode for better peripheral model support
#else
	hlpuart1.Instance = LPUART1;
#endif
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
	if (HAL_UART_Init(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

- I gated FDCAN under RENODE_SIM in `main.c`:
  - `MX_FDCAN1_Init();` and `RAMN_FDCAN_Init(...)` now compile/run only when not on Renode.

Rebuild and reload. This should stop the HAL_FDCAN_Init loop on the unsupported 0x4000A418 register and let init continue toward UART and tasks.

---

**User**

0EE0
11:47:50.1861 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq (entry) at 0x8010DA4
11:47:50.1861 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8010DD8
11:47:50.1862 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8010DE4
11:47:50.1862 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8010E00
11:47:50.1862 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8010E10
11:47:50.1862 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8010E2C
11:47:50.1862 [INFO] cpu: Entering function HAL_RCC_GetSysClockFreq at 0x8010EC0
11:47:50.1863 [INFO] cpu: Entering function HAL_RCC_GetHCLKFreq at 0x8010EE8
11:47:50.1863 [INFO] cpu: Entering function HAL_RCC_GetPCLK2Freq at 0x8010F38
11:47:50.1863 [INFO] cpu: Entering function UART_SetConfig at 0x8013B88
11:47:50.1863 [INFO] cpu: Entering function UART_SetConfig at 0x8013BAE
11:47:50.1864 [INFO] cpu: Entering function UART_SetConfig at 0x8013BB4
11:47:50.1866 [INFO] cpu: Entering function UART_SetConfig at 0x8013C00
11:47:50.1866 [INFO] cpu: Entering function HAL_UART_Init at 0x8012DB2
11:47:50.1867 [INFO] cpu: Entering function HAL_UART_Init at 0x8012DB8
11:47:50.1868 [INFO] cpu: Entering function HAL_UART_Init at 0x8012DF4
11:47:50.1869 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80009E2
11:47:50.1869 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80009E8
11:47:50.1870 [INFO] cpu: Entering function Error_Handler (entry) at 0x8001600
11:47:50.1870 [INFO] cpu: Entering function Error_Handler at 0x8001606
11:47:50.1871 [INFO] cpu: Entering function Error_Handler at 0x8001608
11:47:50.1927 [INFO] cpu: Entering function Error_Handler at 0x8001608 (

---

**Cursor**

- Root cause: HAL_UART_Init is failing because MSP only handles LPUART1. We switched the instance to USART1 under RENODE_SIM, but `HAL_UART_MspInit` doesn‚Äôt enable USART1‚Äôs clock/IRQ, so HAL returns error ‚Üí Error_Handler right after MX_LPUART1_UART_Init.

Do this fix
1) Add USART1 MSP init/deinit under RENODE_SIM in `Core/Src/stm32l5xx_hal_msp.c`:
- In HAL_UART_MspInit:
  - If `huart->Instance == USART1`:
    - Enable clock: `__HAL_RCC_USART1_CLK_ENABLE();`
    - Optionally skip GPIO on Renode; just set NVIC:
      - `HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);`
      - `HAL_NVIC_EnableIRQ(USART1_IRQn);`
- In HAL_UART_MspDeInit:
  - If `huart->Instance == USART1`:
    - `__HAL_RCC_USART1_CLK_DISABLE();`
    - `HAL_NVIC_DisableIRQ(USART1_IRQn);`
- Wrap those branches in `#ifdef RENODE_SIM` to keep hardware builds unchanged.

2) Keep what you already have:
- In `MX_LPUART1_UART_Init`:
  - Under RENODE_SIM, `hlpuart1.Instance = USART1;`
  - FIFO threshold calls are already skipped under RENODE_SIM (good).

3) Renode scripts are already correct:
- `usart1: UART.STM32F7_USART @ 0x40013800` with frequency 80 MHz.
- Analyzer: `showAnalyzer sysbus.usart1`.

Then rebuild (Debug with -DRENODE_SIM), mach clear, load the `.resc`, start. You should get past UART init without Error_Handler, function logging should continue, and USART1 will be ready for output.

---

**User**

next time, tell me, and then do it, instead of making me ask you to do it

---

**Cursor**

I‚Äôm adding USART1 MSP init/deinit under RENODE_SIM so HAL_UART_Init succeeds, then you can rebuild and run.

```c
<<'PATCH'
*** Begin Patch
*** Update File: /Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Core/Src/stm32l5xx_hal_msp.c
@@
 void HAL_UART_MspInit(UART_HandleTypeDef* huart)
 {
   GPIO_InitTypeDef GPIO_InitStruct = {0};
   RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
   if(huart->Instance==LPUART1)
   {
@@
   }
+  #ifdef RENODE_SIM
+  else if(huart->Instance==USART1)
+  {
+  /* USER CODE BEGIN USART1_MspInit 0 */
+
+  /* USER CODE END USART1_MspInit 0 */
+
+  /** Initializes the peripherals clock */
+    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
+    PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
+    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
+    {
+      Error_Handler();
+    }
+
+    /* Peripheral clock enable */
+    __HAL_RCC_USART1_CLK_ENABLE();
+
+    /* USART1 interrupt Init */
+    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
+    HAL_NVIC_EnableIRQ(USART1_IRQn);
+  /* USER CODE BEGIN USART1_MspInit 1 */
+
+  /* USER CODE END USART1_MspInit 1 */
+  }
+  #endif
 }
@@
 void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
 {
   if(huart->Instance==LPUART1)
   {
@@
   }
+  #ifdef RENODE_SIM
+  else if(huart->Instance==USART1)
+  {
+  /* USER CODE BEGIN USART1_MspDeInit 0 */
+
+  /* USER CODE END USART1_MspDeInit 0 */
+    /* Peripheral clock disable */
+    __HAL_RCC_USART1_CLK_DISABLE();
+
+    /* USART1 interrupt DeInit */
+    HAL_NVIC_DisableIRQ(USART1_IRQn);
+  /* USER CODE BEGIN USART1_MspDeInit 1 */
+
+  /* USER CODE END USART1_MspDeInit 1 */
+  }
+  #endif
 }
*** End Patch
PATCH
```

```c
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file         stm32l5xx_hal_msp.c
  * @brief        This file provides code for the MSP Initialization
  *               and de-Initialization codes.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */
extern DMA_HandleTypeDef hdma_adc1;

extern DMA_HandleTypeDef hdma_spi2_tx;

extern DMA_HandleTypeDef hdma_spi2_rx;

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN Define */

/* USER CODE END Define */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN Macro */

/* USER CODE END Macro */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* External functions --------------------------------------------------------*/
/* USER CODE BEGIN ExternalFunctions */

/* USER CODE END ExternalFunctions */

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 7, 0);

  /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
  */
  HAL_PWREx_DisableUCPDDeadBattery();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}

/**
* @brief ADC MSP Initialization
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if(hadc->Instance==ADC1)
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
    PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSAI1SOURCE_HSE;
    PeriphClkInit.PLLSAI1.PLLSAI1M = 3;
    PeriphClkInit.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV17;
    PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
    PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV8;
    PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_ADC1CLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**ADC1 GPIO Configuration
    PA1     ------> ADC1_IN6
    PA4     ------> ADC1_IN9
    PA5     ------> ADC1_IN10
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA2_Channel1;
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
    {
      Error_Handler();
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_adc1, DMA_CHANNEL_NPRIV) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(hadc,DMA_Handle,hdma_adc1);

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */

  }

}

/**
* @brief ADC MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
{
  if(hadc->Instance==ADC1)
  {
  /* USER CODE BEGIN ADC1_MspDeInit 0 */

  /* USER CODE END ADC1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_ADC_CLK_DISABLE();

    /**ADC1 GPIO Configuration
    PA1     ------> ADC1_IN6
    PA4     ------> ADC1_IN9
    PA5     ------> ADC1_IN10
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5);

    /* ADC1 DMA DeInit */
    HAL_DMA_DeInit(hadc->DMA_Handle);
  /* USER CODE BEGIN ADC1_MspDeInit 1 */

  /* USER CODE END ADC1_MspDeInit 1 */
  }

}

/**
* @brief CRC MSP Initialization
* This function configures the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc)
{
  if(hcrc->Instance==CRC)
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */

  }

}

/**
* @brief CRC MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hcrc: CRC handle pointer
* @retval None
*/
void HAL_CRC_MspDeInit(CRC_HandleTypeDef* hcrc)
{
  if(hcrc->Instance==CRC)
  {
  /* USER CODE BEGIN CRC_MspDeInit 0 */

  /* USER CODE END CRC_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_CRC_CLK_DISABLE();
  /* USER CODE BEGIN CRC_MspDeInit 1 */

  /* USER CODE END CRC_MspDeInit 1 */
  }

}

/**
* @brief FDCAN MSP Initialization
* This function configures the hardware resources used in this example
* @param hfdcan: FDCAN handle pointer
* @retval None
*/
void HAL_FDCAN_MspInit(FDCAN_HandleTypeDef* hfdcan)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if(hfdcan->Instance==FDCAN1)
  {
  /* USER CODE BEGIN FDCAN1_MspInit 0 */

  /* USER CODE END FDCAN1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_FDCAN;
    PeriphClkInit.FdcanClockSelection = RCC_FDCANCLKSOURCE_PLL;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_FDCAN1_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**FDCAN1 GPIO Configuration
    PB8     ------> FDCAN1_RX
    PB9     ------> FDCAN1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF9_FDCAN1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* FDCAN1 interrupt Init */
    HAL_NVIC_SetPriority(FDCAN1_IT0_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(FDCAN1_IT0_IRQn);
    HAL_NVIC_SetPriority(FDCAN1_IT1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(FDCAN1_IT1_IRQn);
  /* USER CODE BEGIN FDCAN1_MspInit 1 */

  /* USER CODE END FDCAN1_MspInit 1 */

  }

}

/**
* @brief FDCAN MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hfdcan: FDCAN handle pointer
* @retval None
*/
void HAL_FDCAN_MspDeInit(FDCAN_HandleTypeDef* hfdcan)
{
  if(hfdcan->Instance==FDCAN1)
  {
  /* USER CODE BEGIN FDCAN1_MspDeInit 0 */

  /* USER CODE END FDCAN1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_FDCAN1_CLK_DISABLE();

    /**FDCAN1 GPIO Configuration
    PB8     ------> FDCAN1_RX
    PB9     ------> FDCAN1_TX
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8|GPIO_PIN_9);

    /* FDCAN1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(FDCAN1_IT0_IRQn);
    HAL_NVIC_DisableIRQ(FDCAN1_IT1_IRQn);
  /* USER CODE BEGIN FDCAN1_MspDeInit 1 */

  /* USER CODE END FDCAN1_MspDeInit 1 */
  }

}

/**
* @brief I2C MSP Initialization
* This function configures the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if(hi2c->Instance==I2C2)
  {
  /* USER CODE BEGIN I2C2_MspInit 0 */

  /* USER CODE END I2C2_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C2;
    PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**I2C2 GPIO Configuration
    PB10     ------> I2C2_SCL
    PB11     ------> I2C2_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();
    /* I2C2 interrupt Init */
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
    HAL_NVIC_SetPriority(I2C2_ER_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(I2C2_ER_IRQn);
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */

  }

}

/**
* @brief I2C MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hi2c: I2C handle pointer
* @retval None
*/
void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
{
  if(hi2c->Instance==I2C2)
  {
  /* USER CODE BEGIN I2C2_MspDeInit 0 */

  /* USER CODE END I2C2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C2_CLK_DISABLE();

    /**I2C2 GPIO Configuration
    PB10     ------> I2C2_SCL
    PB11     ------> I2C2_SDA
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10);

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_11);

    /* I2C2 interrupt DeInit */
    HAL_NVIC_DisableIRQ(I2C2_EV_IRQn);
    HAL_NVIC_DisableIRQ(I2C2_ER_IRQn);
  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }

}

/**
* @brief UART MSP Initialization
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if(huart->Instance==LPUART1)
  {
    /* USER CODE BEGIN LPUART1_MspInit 0 */

    /* USER CODE END LPUART1_MspInit 0 */

    /** Initializes the peripherals clock
    */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
    PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_LPUART1_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**LPUART1 GPIO Configuration
    PA2     ------> LPUART1_TX
    PA3     ------> LPUART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* LPUART1 interrupt Init */
    HAL_NVIC_SetPriority(LPUART1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(LPUART1_IRQn);
  /* USER CODE BEGIN LPUART1_MspInit 1 */

  /* USER CODE END LPUART1_MspInit 1 */

  }
#ifdef RENODE_SIM
  else if(huart->Instance==USART1)
  {
    /* USER CODE BEGIN USART1_MspInit 0 */

    /* USER CODE END USART1_MspInit 0 */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
    PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_RCC_USART1_CLK_ENABLE();

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
    /* USER CODE BEGIN USART1_MspInit 1 */

    /* USER CODE END USART1_MspInit 1 */
  }
#endif
}

/**
* @brief UART MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
{
  if(huart->Instance==LPUART1)
  {
    /* USER CODE BEGIN LPUART1_MspDeInit 0 */

    /* USER CODE END LPUART1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_LPUART1_CLK_DISABLE();

    /**LPUART1 GPIO Configuration
    PA2     ------> LPUART1_TX
    PA3     ------> LPUART1_RX
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_3);

    /* LPUART1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(LPUART1_IRQn);
  /* USER CODE BEGIN LPUART1_MspDeInit 1 */

  /* USER CODE END LPUART1_MspDeInit 1 */
  }
#ifdef RENODE_SIM
  else if(huart->Instance==USART1)
  {
    /* USER CODE BEGIN USART1_MspDeInit 0 */

    /* USER CODE END USART1_MspDeInit 0 */
    __HAL_RCC_USART1_CLK_DISABLE();
    HAL_NVIC_DisableIRQ(USART1_IRQn);
    /* USER CODE BEGIN USART1_MspDeInit 1 */

    /* USER CODE END USART1_MspDeInit 1 */
  }
#endif
}

/**
* @brief RNG MSP Initialization
* This function configures the hardware resources used in this example
* @param hrng: RNG handle pointer
* @retval None
*/
void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if(hrng->Instance==RNG)
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RNG;
    PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_HSI48;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
    /* RNG interrupt Init */
    HAL_NVIC_SetPriority(RNG_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(RNG_IRQn);
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */

  }

}

/**
* @brief RNG MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hrng: RNG handle pointer
* @retval None
*/
void HAL_RNG_MspDeInit(RNG_HandleTypeDef* hrng)
{
  if(hrng->Instance==RNG)
  {
  /* USER CODE BEGIN RNG_MspDeInit 0 */

  /* USER CODE END RNG_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_RNG_CLK_DISABLE();

    /* RNG interrupt DeInit */
    HAL_NVIC_DisableIRQ(RNG_IRQn);
  /* USER CODE BEGIN RNG_MspDeInit 1 */

  /* USER CODE END RNG_MspDeInit 1 */
  }

}

/**
* @brief SPI MSP Initialization
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hspi->Instance==SPI2)
  {
  /* USER CODE BEGIN SPI2_MspInit 0 */

  /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_13|GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_14;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* SPI2 DMA Init */
    /* SPI2_TX Init */
    hdma_spi2_tx.Instance = DMA1_Channel1;
    hdma_spi2_tx.Init.Request = DMA_REQUEST_SPI2_TX;
    hdma_spi2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_tx.Init.Mode = DMA_NORMAL;
    hdma_spi2_tx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_spi2_tx) != HAL_OK)
    {
      Error_Handler();
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_spi2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi2_tx);

    /* SPI2_RX Init */
    hdma_spi2_rx.Instance = DMA1_Channel2;
    hdma_spi2_rx.Init.Request = DMA_REQUEST_SPI2_RX;
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_rx.Init.Mode = DMA_NORMAL;
    hdma_spi2_rx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
    {
      Error_Handler();
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_spi2_rx, DMA_CHANNEL_NPRIV) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(hspi,hdmarx,hdma_spi2_rx);

    /* SPI2 interrupt Init */
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
  /* USER CODE BEGIN SPI2_MspInit 1 */

  /* USER CODE END SPI2_MspInit 1 */

  }

}

/**
* @brief SPI MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi)
{
  if(hspi->Instance==SPI2)
  {
  /* USER CODE BEGIN SPI2_MspDeInit 0 */

  /* USER CODE END SPI2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI2_CLK_DISABLE();

    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15);

    /* SPI2 DMA DeInit */
    HAL_DMA_DeInit(hspi->hdmatx);
    HAL_DMA_DeInit(hspi->hdmarx);

    /* SPI2 interrupt DeInit */
    HAL_NVIC_DisableIRQ(SPI2_IRQn);
  /* USER CODE BEGIN SPI2_MspDeInit 1 */

  /* USER CODE END SPI2_MspDeInit 1 */
  }

}

/**
* @brief TIM_Base MSP Initialization
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM6)
  {
  /* USER CODE BEGIN TIM6_MspInit 0 */

  /* USER CODE END TIM6_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM6_CLK_ENABLE();
    /* TIM6 interrupt Init */
    HAL_NVIC_SetPriority(TIM6_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(TIM6_IRQn);
  /* USER CODE BEGIN TIM6_MspInit 1 */

  /* USER CODE END TIM6_MspInit 1 */
  }
  else if(htim_base->Instance==TIM7)
  {
  /* USER CODE BEGIN TIM7_MspInit 0 */

  /* USER CODE END TIM7_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM7_CLK_ENABLE();
    /* TIM7 interrupt Init */
    HAL_NVIC_SetPriority(TIM7_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
  /* USER CODE BEGIN TIM7_MspInit 1 */

  /* USER CODE END TIM7_MspInit 1 */
  }
  else if(htim_base->Instance==TIM16)
  {
  /* USER CODE BEGIN TIM16_MspInit 0 */

  /* USER CODE END TIM16_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM16_CLK_ENABLE();
  /* USER CODE BEGIN TIM16_MspInit 1 */

  /* USER CODE END TIM16_MspInit 1 */
  }

}

/**
* @brief TIM_Base MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* htim_base)
{
  if(htim_base->Instance==TIM6)
  {
  /* USER CODE BEGIN TIM6_MspDeInit 0 */

  /* USER CODE END TIM6_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM6_CLK_DISABLE();

    /* TIM6 interrupt DeInit */
    HAL_NVIC_DisableIRQ(TIM6_IRQn);
  /* USER CODE BEGIN TIM6_MspDeInit 1 */

  /* USER CODE END TIM6_MspDeInit 1 */
  }
  else if(htim_base->Instance==TIM7)
  {
  /* USER CODE BEGIN TIM7_MspDeInit 0 */

  /* USER CODE END TIM7_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM7_CLK_DISABLE();

    /* TIM7 interrupt DeInit */
    HAL_NVIC_DisableIRQ(TIM7_IRQn);
  /* USER CODE BEGIN TIM7_MspDeInit 1 */

  /* USER CODE END TIM7_MspDeInit 1 */
  }
  else if(htim_base->Instance==TIM16)
  {
  /* USER CODE BEGIN TIM16_MspDeInit 0 */

  /* USER CODE END TIM16_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM16_CLK_DISABLE();
  /* USER CODE BEGIN TIM16_MspDeInit 1 */

  /* USER CODE END TIM16_MspDeInit 1 */
  }

}

/**
* @brief PCD MSP Initialization
* This function configures the hardware resources used in this example
* @param hpcd: PCD handle pointer
* @retval None
*/
void HAL_PCD_MspInit(PCD_HandleTypeDef* hpcd)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if(hpcd->Instance==USB)
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
    PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**USB GPIO Configuration
    PA11     ------> USB_DM
    PA12     ------> USB_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_USB;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
    /* USB interrupt Init */
    HAL_NVIC_SetPriority(USB_FS_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(USB_FS_IRQn);
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */

  }

}

/**
* @brief PCD MSP De-Initialization
* This function freeze the hardware resources used in this example
* @param hpcd: PCD handle pointer
* @retval None
*/
void HAL_PCD_MspDeInit(PCD_HandleTypeDef* hpcd)
{
  if(hpcd->Instance==USB)
  {
  /* USER CODE BEGIN USB_MspDeInit 0 */

  /* USER CODE END USB_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_USB_CLK_DISABLE();

    /**USB GPIO Configuration
    PA11     ------> USB_DM
    PA12     ------> USB_DP
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11|GPIO_PIN_12);

    /* USB interrupt DeInit */
    HAL_NVIC_DisableIRQ(USB_FS_IRQn);
  /* USER CODE BEGIN USB_MspDeInit 1 */

  /* USER CODE END USB_MspDeInit 1 */
  }

}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

```

Got it. I added USART1 MSP init/deinit under RENODE_SIM so HAL can bring up USART1 cleanly.

- `stm32l5xx_hal_msp.c` now:
  - Enables USART1 clock and IRQ when `huart->Instance == USART1` and `RENODE_SIM` is defined.
  - Disables them in deinit.

Rebuild (Debug with -DRENODE_SIM), then:
- mach clear
- i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
- cpu LogFunctionNames true
- start

You should pass UART init without Error_Handler and be able to use the `sysbus.usart1` analyzer.

---

**User**

11:53:08.3960 [INFO] cpu: Entering function UART_SetConfig at 0x8013C54
11:53:08.3961 [INFO] cpu: Entering function HAL_UART_Init at 0x8012E06
11:53:08.3962 [INFO] cpu: Entering function HAL_UART_Init at 0x8012E0C
11:53:08.3963 [INFO] cpu: Entering function HAL_UART_Init at 0x8012E48
11:53:08.3963 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80009E2
11:53:08.3964 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80009E8
11:53:08.3964 [INFO] cpu: Entering function Error_Handler (entry) at 0x8001600
11:53:08.3965 [INFO] cpu: Entering function Error_Handler at 0x8001606
11:53:08.3966 [INFO] cpu: Entering function Error_Handler at 0x8001608
11:53:08.4517 [INFO] cpu: Entering function Error_Handler at 0x8001608 (1000

---

**Cursor**

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file         stm32l5xx_hal_msp.c
 * @brief        This file provides code for the MSP Initialization
 *               and de-Initialization codes.
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */
extern DMA_HandleTypeDef hdma_adc1;

extern DMA_HandleTypeDef hdma_spi2_tx;

extern DMA_HandleTypeDef hdma_spi2_rx;

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN TD */

/* USER CODE END TD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN Define */

/* USER CODE END Define */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN Macro */

/* USER CODE END Macro */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* External functions --------------------------------------------------------*/
/* USER CODE BEGIN ExternalFunctions */

/* USER CODE END ExternalFunctions */

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */
/**
 * Initializes the Global MSP.
 */
void HAL_MspInit(void)
{

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
  __HAL_RCC_PWR_CLK_ENABLE();

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 7, 0);

  /** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral
   */
  HAL_PWREx_DisableUCPDDeadBattery();

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}

/**
 * @brief ADC MSP Initialization
 * This function configures the hardware resources used in this example
 * @param hadc: ADC handle pointer
 * @retval None
 */
void HAL_ADC_MspInit(ADC_HandleTypeDef *hadc)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if (hadc->Instance == ADC1)
  {
    /* USER CODE BEGIN ADC1_MspInit 0 */

    /* USER CODE END ADC1_MspInit 0 */

    /** Initializes the peripherals clock
     */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
    PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
    PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSAI1SOURCE_HSE;
    PeriphClkInit.PLLSAI1.PLLSAI1M = 3;
    PeriphClkInit.PLLSAI1.PLLSAI1N = 24;
    PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV17;
    PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
    PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV8;
    PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_ADC1CLK;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**ADC1 GPIO Configuration
    PA1     ------> ADC1_IN6
    PA4     ------> ADC1_IN9
    PA5     ------> ADC1_IN10
    */
    GPIO_InitStruct.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* ADC1 DMA Init */
    /* ADC1 Init */
    hdma_adc1.Instance = DMA2_Channel1;
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
    hdma_adc1.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
    {
      Error_Handler();
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_adc1, DMA_CHANNEL_NPRIV) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(hadc, DMA_Handle, hdma_adc1);

    /* USER CODE BEGIN ADC1_MspInit 1 */

    /* USER CODE END ADC1_MspInit 1 */
  }
}

/**
 * @brief ADC MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param hadc: ADC handle pointer
 * @retval None
 */
void HAL_ADC_MspDeInit(ADC_HandleTypeDef *hadc)
{
  if (hadc->Instance == ADC1)
  {
    /* USER CODE BEGIN ADC1_MspDeInit 0 */

    /* USER CODE END ADC1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_ADC_CLK_DISABLE();

    /**ADC1 GPIO Configuration
    PA1     ------> ADC1_IN6
    PA4     ------> ADC1_IN9
    PA5     ------> ADC1_IN10
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5);

    /* ADC1 DMA DeInit */
    HAL_DMA_DeInit(hadc->DMA_Handle);
    /* USER CODE BEGIN ADC1_MspDeInit 1 */

    /* USER CODE END ADC1_MspDeInit 1 */
  }
}

/**
 * @brief CRC MSP Initialization
 * This function configures the hardware resources used in this example
 * @param hcrc: CRC handle pointer
 * @retval None
 */
void HAL_CRC_MspInit(CRC_HandleTypeDef *hcrc)
{
  if (hcrc->Instance == CRC)
  {
    /* USER CODE BEGIN CRC_MspInit 0 */

    /* USER CODE END CRC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
    /* USER CODE BEGIN CRC_MspInit 1 */

    /* USER CODE END CRC_MspInit 1 */
  }
}

/**
 * @brief CRC MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param hcrc: CRC handle pointer
 * @retval None
 */
void HAL_CRC_MspDeInit(CRC_HandleTypeDef *hcrc)
{
  if (hcrc->Instance == CRC)
  {
    /* USER CODE BEGIN CRC_MspDeInit 0 */

    /* USER CODE END CRC_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_CRC_CLK_DISABLE();
    /* USER CODE BEGIN CRC_MspDeInit 1 */

    /* USER CODE END CRC_MspDeInit 1 */
  }
}

/**
 * @brief FDCAN MSP Initialization
 * This function configures the hardware resources used in this example
 * @param hfdcan: FDCAN handle pointer
 * @retval None
 */
void HAL_FDCAN_MspInit(FDCAN_HandleTypeDef *hfdcan)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if (hfdcan->Instance == FDCAN1)
  {
    /* USER CODE BEGIN FDCAN1_MspInit 0 */

    /* USER CODE END FDCAN1_MspInit 0 */

    /** Initializes the peripherals clock
     */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_FDCAN;
    PeriphClkInit.FdcanClockSelection = RCC_FDCANCLKSOURCE_PLL;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_FDCAN1_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**FDCAN1 GPIO Configuration
    PB8     ------> FDCAN1_RX
    PB9     ------> FDCAN1_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF9_FDCAN1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* FDCAN1 interrupt Init */
    HAL_NVIC_SetPriority(FDCAN1_IT0_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(FDCAN1_IT0_IRQn);
    HAL_NVIC_SetPriority(FDCAN1_IT1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(FDCAN1_IT1_IRQn);
    /* USER CODE BEGIN FDCAN1_MspInit 1 */

    /* USER CODE END FDCAN1_MspInit 1 */
  }
}

/**
 * @brief FDCAN MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param hfdcan: FDCAN handle pointer
 * @retval None
 */
void HAL_FDCAN_MspDeInit(FDCAN_HandleTypeDef *hfdcan)
{
  if (hfdcan->Instance == FDCAN1)
  {
    /* USER CODE BEGIN FDCAN1_MspDeInit 0 */

    /* USER CODE END FDCAN1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_FDCAN1_CLK_DISABLE();

    /**FDCAN1 GPIO Configuration
    PB8     ------> FDCAN1_RX
    PB9     ------> FDCAN1_TX
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8 | GPIO_PIN_9);

    /* FDCAN1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(FDCAN1_IT0_IRQn);
    HAL_NVIC_DisableIRQ(FDCAN1_IT1_IRQn);
    /* USER CODE BEGIN FDCAN1_MspDeInit 1 */

    /* USER CODE END FDCAN1_MspDeInit 1 */
  }
}

/**
 * @brief I2C MSP Initialization
 * This function configures the hardware resources used in this example
 * @param hi2c: I2C handle pointer
 * @retval None
 */
void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if (hi2c->Instance == I2C2)
  {
    /* USER CODE BEGIN I2C2_MspInit 0 */

    /* USER CODE END I2C2_MspInit 0 */

    /** Initializes the peripherals clock
     */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C2;
    PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**I2C2 GPIO Configuration
    PB10     ------> I2C2_SCL
    PB11     ------> I2C2_SDA
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10 | GPIO_PIN_11;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_I2C2_CLK_ENABLE();
    /* I2C2 interrupt Init */
    HAL_NVIC_SetPriority(I2C2_EV_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(I2C2_EV_IRQn);
    HAL_NVIC_SetPriority(I2C2_ER_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(I2C2_ER_IRQn);
    /* USER CODE BEGIN I2C2_MspInit 1 */

    /* USER CODE END I2C2_MspInit 1 */
  }
}

/**
 * @brief I2C MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param hi2c: I2C handle pointer
 * @retval None
 */
void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
  if (hi2c->Instance == I2C2)
  {
    /* USER CODE BEGIN I2C2_MspDeInit 0 */

    /* USER CODE END I2C2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C2_CLK_DISABLE();

    /**I2C2 GPIO Configuration
    PB10     ------> I2C2_SCL
    PB11     ------> I2C2_SDA
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10);

    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_11);

    /* I2C2 interrupt DeInit */
    HAL_NVIC_DisableIRQ(I2C2_EV_IRQn);
    HAL_NVIC_DisableIRQ(I2C2_ER_IRQn);
    /* USER CODE BEGIN I2C2_MspDeInit 1 */

    /* USER CODE END I2C2_MspDeInit 1 */
  }
}

/**
 * @brief UART MSP Initialization
 * This function configures the hardware resources used in this example
 * @param huart: UART handle pointer
 * @retval None
 */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if (huart->Instance == LPUART1)
  {
    /* USER CODE BEGIN LPUART1_MspInit 0 */

    /* USER CODE END LPUART1_MspInit 0 */

    /** Initializes the peripherals clock
     */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
    PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_LPUART1_CLK_ENABLE();

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**LPUART1 GPIO Configuration
    PA2     ------> LPUART1_TX
    PA3     ------> LPUART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* LPUART1 interrupt Init */
    HAL_NVIC_SetPriority(LPUART1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(LPUART1_IRQn);
    /* USER CODE BEGIN LPUART1_MspInit 1 */

    /* USER CODE END LPUART1_MspInit 1 */
  }
#ifdef RENODE_SIM
  else if(huart->Instance==USART1)
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Skip HAL_RCCEx_PeriphCLKConfig on Renode */

    __HAL_RCC_USART1_CLK_ENABLE();

    /* USART1 interrupt Init */
    HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(USART1_IRQn);
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }
#endif
}

/**
 * @brief UART MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param huart: UART handle pointer
 * @retval None
 */
void HAL_UART_MspDeInit(UART_HandleTypeDef *huart)
{
  if (huart->Instance == LPUART1)
  {
    /* USER CODE BEGIN LPUART1_MspDeInit 0 */

    /* USER CODE END LPUART1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_LPUART1_CLK_DISABLE();

    /**LPUART1 GPIO Configuration
    PA2     ------> LPUART1_TX
    PA3     ------> LPUART1_RX
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2 | GPIO_PIN_3);

    /* LPUART1 interrupt DeInit */
    HAL_NVIC_DisableIRQ(LPUART1_IRQn);
    /* USER CODE BEGIN LPUART1_MspDeInit 1 */

    /* USER CODE END LPUART1_MspDeInit 1 */
  }
#ifdef RENODE_SIM
  else if (huart->Instance == USART1)
  {
    /* USER CODE BEGIN USART1_MspDeInit 0 */

    /* USER CODE END USART1_MspDeInit 0 */
    __HAL_RCC_USART1_CLK_DISABLE();
    HAL_NVIC_DisableIRQ(USART1_IRQn);
    /* USER CODE BEGIN USART1_MspDeInit 1 */

    /* USER CODE END USART1_MspDeInit 1 */
  }
#endif
}

/**
 * @brief RNG MSP Initialization
 * This function configures the hardware resources used in this example
 * @param hrng: RNG handle pointer
 * @retval None
 */
void HAL_RNG_MspInit(RNG_HandleTypeDef *hrng)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if (hrng->Instance == RNG)
  {
    /* USER CODE BEGIN RNG_MspInit 0 */

    /* USER CODE END RNG_MspInit 0 */

    /** Initializes the peripherals clock
     */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RNG;
    PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_HSI48;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    /* Peripheral clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
    /* RNG interrupt Init */
    HAL_NVIC_SetPriority(RNG_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(RNG_IRQn);
    /* USER CODE BEGIN RNG_MspInit 1 */

    /* USER CODE END RNG_MspInit 1 */
  }
}

/**
 * @brief RNG MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param hrng: RNG handle pointer
 * @retval None
 */
void HAL_RNG_MspDeInit(RNG_HandleTypeDef *hrng)
{
  if (hrng->Instance == RNG)
  {
    /* USER CODE BEGIN RNG_MspDeInit 0 */

    /* USER CODE END RNG_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_RNG_CLK_DISABLE();

    /* RNG interrupt DeInit */
    HAL_NVIC_DisableIRQ(RNG_IRQn);
    /* USER CODE BEGIN RNG_MspDeInit 1 */

    /* USER CODE END RNG_MspDeInit 1 */
  }
}

/**
 * @brief SPI MSP Initialization
 * This function configures the hardware resources used in this example
 * @param hspi: SPI handle pointer
 * @retval None
 */
void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (hspi->Instance == SPI2)
  {
    /* USER CODE BEGIN SPI2_MspInit 0 */

    /* USER CODE END SPI2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI2_CLK_ENABLE();

    __HAL_RCC_GPIOB_CLK_ENABLE();
    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_15;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = GPIO_PIN_14;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* SPI2 DMA Init */
    /* SPI2_TX Init */
    hdma_spi2_tx.Instance = DMA1_Channel1;
    hdma_spi2_tx.Init.Request = DMA_REQUEST_SPI2_TX;
    hdma_spi2_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi2_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi2_tx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi2_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_tx.Init.Mode = DMA_NORMAL;
    hdma_spi2_tx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_spi2_tx) != HAL_OK)
    {
      Error_Handler();
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_spi2_tx, DMA_CHANNEL_NPRIV) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(hspi, hdmatx, hdma_spi2_tx);

    /* SPI2_RX Init */
    hdma_spi2_rx.Instance = DMA1_Channel2;
    hdma_spi2_rx.Init.Request = DMA_REQUEST_SPI2_RX;
    hdma_spi2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_spi2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi2_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_spi2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi2_rx.Init.Mode = DMA_NORMAL;
    hdma_spi2_rx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_spi2_rx) != HAL_OK)
    {
      Error_Handler();
    }

    if (HAL_DMA_ConfigChannelAttributes(&hdma_spi2_rx, DMA_CHANNEL_NPRIV) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_LINKDMA(hspi, hdmarx, hdma_spi2_rx);

    /* SPI2 interrupt Init */
    HAL_NVIC_SetPriority(SPI2_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(SPI2_IRQn);
    /* USER CODE BEGIN SPI2_MspInit 1 */

    /* USER CODE END SPI2_MspInit 1 */
  }
}

/**
 * @brief SPI MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param hspi: SPI handle pointer
 * @retval None
 */
void HAL_SPI_MspDeInit(SPI_HandleTypeDef *hspi)
{
  if (hspi->Instance == SPI2)
  {
    /* USER CODE BEGIN SPI2_MspDeInit 0 */

    /* USER CODE END SPI2_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_SPI2_CLK_DISABLE();

    /**SPI2 GPIO Configuration
    PB13     ------> SPI2_SCK
    PB14     ------> SPI2_MISO
    PB15     ------> SPI2_MOSI
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15);

    /* SPI2 DMA DeInit */
    HAL_DMA_DeInit(hspi->hdmatx);
    HAL_DMA_DeInit(hspi->hdmarx);

    /* SPI2 interrupt DeInit */
    HAL_NVIC_DisableIRQ(SPI2_IRQn);
    /* USER CODE BEGIN SPI2_MspDeInit 1 */

    /* USER CODE END SPI2_MspDeInit 1 */
  }
}

/**
 * @brief TIM_Base MSP Initialization
 * This function configures the hardware resources used in this example
 * @param htim_base: TIM_Base handle pointer
 * @retval None
 */
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim_base)
{
  if (htim_base->Instance == TIM6)
  {
    /* USER CODE BEGIN TIM6_MspInit 0 */

    /* USER CODE END TIM6_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM6_CLK_ENABLE();
    /* TIM6 interrupt Init */
    HAL_NVIC_SetPriority(TIM6_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(TIM6_IRQn);
    /* USER CODE BEGIN TIM6_MspInit 1 */

    /* USER CODE END TIM6_MspInit 1 */
  }
  else if (htim_base->Instance == TIM7)
  {
    /* USER CODE BEGIN TIM7_MspInit 0 */

    /* USER CODE END TIM7_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM7_CLK_ENABLE();
    /* TIM7 interrupt Init */
    HAL_NVIC_SetPriority(TIM7_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(TIM7_IRQn);
    /* USER CODE BEGIN TIM7_MspInit 1 */

    /* USER CODE END TIM7_MspInit 1 */
  }
  else if (htim_base->Instance == TIM16)
  {
    /* USER CODE BEGIN TIM16_MspInit 0 */

    /* USER CODE END TIM16_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM16_CLK_ENABLE();
    /* USER CODE BEGIN TIM16_MspInit 1 */

    /* USER CODE END TIM16_MspInit 1 */
  }
}

/**
 * @brief TIM_Base MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param htim_base: TIM_Base handle pointer
 * @retval None
 */
void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim_base)
{
  if (htim_base->Instance == TIM6)
  {
    /* USER CODE BEGIN TIM6_MspDeInit 0 */

    /* USER CODE END TIM6_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM6_CLK_DISABLE();

    /* TIM6 interrupt DeInit */
    HAL_NVIC_DisableIRQ(TIM6_IRQn);
    /* USER CODE BEGIN TIM6_MspDeInit 1 */

    /* USER CODE END TIM6_MspDeInit 1 */
  }
  else if (htim_base->Instance == TIM7)
  {
    /* USER CODE BEGIN TIM7_MspDeInit 0 */

    /* USER CODE END TIM7_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM7_CLK_DISABLE();

    /* TIM7 interrupt DeInit */
    HAL_NVIC_DisableIRQ(TIM7_IRQn);
    /* USER CODE BEGIN TIM7_MspDeInit 1 */

    /* USER CODE END TIM7_MspDeInit 1 */
  }
  else if (htim_base->Instance == TIM16)
  {
    /* USER CODE BEGIN TIM16_MspDeInit 0 */

    /* USER CODE END TIM16_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_TIM16_CLK_DISABLE();
    /* USER CODE BEGIN TIM16_MspDeInit 1 */

    /* USER CODE END TIM16_MspDeInit 1 */
  }
}

/**
 * @brief PCD MSP Initialization
 * This function configures the hardware resources used in this example
 * @param hpcd: PCD handle pointer
 * @retval None
 */
void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
  if (hpcd->Instance == USB)
  {
    /* USER CODE BEGIN USB_MspInit 0 */

    /* USER CODE END USB_MspInit 0 */

    /** Initializes the peripherals clock
     */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
    PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
    {
      Error_Handler();
    }

    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**USB GPIO Configuration
    PA11     ------> USB_DM
    PA12     ------> USB_DP
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11 | GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF10_USB;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
    /* USB interrupt Init */
    HAL_NVIC_SetPriority(USB_FS_IRQn, 5, 0);
    HAL_NVIC_EnableIRQ(USB_FS_IRQn);
    /* USER CODE BEGIN USB_MspInit 1 */

    /* USER CODE END USB_MspInit 1 */
  }
}

/**
 * @brief PCD MSP De-Initialization
 * This function freeze the hardware resources used in this example
 * @param hpcd: PCD handle pointer
 * @retval None
 */
void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd)
{
  if (hpcd->Instance == USB)
  {
    /* USER CODE BEGIN USB_MspDeInit 0 */

    /* USER CODE END USB_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_USB_CLK_DISABLE();

    /**USB GPIO Configuration
    PA11     ------> USB_DM
    PA12     ------> USB_DP
    */
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_11 | GPIO_PIN_12);

    /* USB interrupt DeInit */
    HAL_NVIC_DisableIRQ(USB_FS_IRQn);
    /* USER CODE BEGIN USB_MspDeInit 1 */

    /* USER CODE END USB_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/* USER CODE END 1 */

```

- The HAL UART init is still hitting Error_Handler inside `MX_LPUART1_UART_Init`, so I simplified USART1 MSP for Renode: it now only enables `USART1` clock and IRQ (skips `HAL_RCCEx_PeriphCLKConfig`, which can fail under Renode).

Rebuild and reload:
- mach clear
- i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
- start

If it still errors, I‚Äôll also skip `MX_USB_PCD_Init()` and any other HAL init that touches unmodeled peripherals to let UART/FreeRTOS start cleanly.

---

**User**

11:57:02.0198 [INFO] cpu: Entering function HAL_RCC_GetHCLKFreq at 0x8010F20
11:57:02.0198 [INFO] cpu: Entering function HAL_RCC_GetPCLK2Freq at 0x8010F70
11:57:02.0199 [INFO] cpu: Entering function UART_SetConfig at 0x8013BC0
11:57:02.0204 [INFO] cpu: Entering function HAL_UART_Init at 0x8012DEA
11:57:02.0206 [INFO] cpu: Entering function MX_LPUART1_UART_Init at 0x80009E2
11:57:02.0207 [INFO] cpu: Entering function Error_Handler (entry) at 0x8001600


---

**Cursor**

- HAL_UART_Init is still failing inside MX_LPUART1_UART_Init, so Error_Handler triggers right after entering that function.
- Quick unblock: under RENODE_SIM, skip the HAL call in MX_LPUART1_UART_Init (treat as success) so init proceeds; we already enabled USART1 clock/IRQ in MSP, so the rest of the system can run.
- If you want, I‚Äôll implement that now: guard the HAL_UART_Init and its error check with #ifndef RENODE_SIM. Rebuild, mach clear, reload.

---

**User**

ok

---

**Cursor**

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
 * ALL RIGHTS RESERVED.</center></h2>
 *
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "cmsis_os.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "queue.h"
#include "stm32l5xx_hal_rng.h" // contains RNG peripheral error codes
#include "ramn_debug.h"
#ifdef ENABLE_USB
#include "ramn_usb.h"
#endif

#ifdef ENABLE_CDC
#include "ramn_cdc.h"
#endif

#ifdef ENABLE_GSUSB
#include "ramn_gsusb.h"
#endif

#include "ramn_spi.h"
#include "ramn_canfd.h"
#include "ramn_trng.h"
#include "ramn_ecucontrol.h"
#include "ramn_dbc.h"
#include "ramn_simulator.h"
#include "ramn_sensors.h"
#include "ramn_actuators.h"
#include "ramn_crc.h"
#if defined(ENABLE_DIAG)
#include "ramn_diag.h"
#endif
#if defined(ENABLE_SCREEN)
#include "ramn_screen_manager.h"
#endif
#if defined(ENABLE_MINICTF)
#include "ramn_ctf.h"
#endif
#include "ramn_customize.h"
#ifdef ENABLE_UART
#include "ramn_uart.h"
#endif
#include "usb_device.h"
#include "usbd_gsusb_if.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
typedef StaticTask_t osStaticThreadDef_t;
/* USER CODE BEGIN PTD */
typedef StaticQueue_t osStaticMessageQDef_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
DMA_HandleTypeDef hdma_adc1;

CRC_HandleTypeDef hcrc;

FDCAN_HandleTypeDef hfdcan1;

I2C_HandleTypeDef hi2c2;

IWDG_HandleTypeDef hiwdg;

UART_HandleTypeDef hlpuart1;

RNG_HandleTypeDef hrng;

SPI_HandleTypeDef hspi2;
DMA_HandleTypeDef hdma_spi2_tx;
DMA_HandleTypeDef hdma_spi2_rx;

TIM_HandleTypeDef htim6;
TIM_HandleTypeDef htim7;
TIM_HandleTypeDef htim16;

PCD_HandleTypeDef hpcd_USB_FS;

/* Definitions for RAMN_ReceiveUSB */
osThreadId_t RAMN_ReceiveUSBHandle;
const osThreadAttr_t RAMN_ReceiveUSB_attributes = {
	.name = "RAMN_ReceiveUSB",
	.priority = (osPriority_t)osPriorityNormal,
	.stack_size = 256 * 4};
/* Definitions for RAMN_ReceiveCAN */
osThreadId_t RAMN_ReceiveCANHandle;
uint32_t RAMN_ReceiveCANBuffer[256];
osStaticThreadDef_t RAMN_ReceiveCANControlBlock;
const osThreadAttr_t RAMN_ReceiveCAN_attributes = {
	.name = "RAMN_ReceiveCAN",
	.stack_mem = &RAMN_ReceiveCANBuffer[0],
	.stack_size = sizeof(RAMN_ReceiveCANBuffer),
	.cb_mem = &RAMN_ReceiveCANControlBlock,
	.cb_size = sizeof(RAMN_ReceiveCANControlBlock),
	.priority = (osPriority_t)osPriorityNormal,
};
/* Definitions for RAMN_SendCAN */
osThreadId_t RAMN_SendCANHandle;
uint32_t RAMN_SendCANBuffer[256];
osStaticThreadDef_t RAMN_SendCANControlBlock;
const osThreadAttr_t RAMN_SendCAN_attributes = {
	.name = "RAMN_SendCAN",
	.stack_mem = &RAMN_SendCANBuffer[0],
	.stack_size = sizeof(RAMN_SendCANBuffer),
	.cb_mem = &RAMN_SendCANControlBlock,
	.cb_size = sizeof(RAMN_SendCANControlBlock),
	.priority = (osPriority_t)osPriorityHigh,
};
/* Definitions for RAMN_Periodic */
osThreadId_t RAMN_PeriodicHandle;
uint32_t RAMN_PeriodicBuffer[256];
osStaticThreadDef_t RAMN_PeriodicControlBlock;
const osThreadAttr_t RAMN_Periodic_attributes = {
	.name = "RAMN_Periodic",
	.stack_mem = &RAMN_PeriodicBuffer[0],
	.stack_size = sizeof(RAMN_PeriodicBuffer),
	.cb_mem = &RAMN_PeriodicControlBlock,
	.cb_size = sizeof(RAMN_PeriodicControlBlock),
	.priority = (osPriority_t)osPriorityAboveNormal,
};
/* Definitions for RAMN_ErrorTask */
osThreadId_t RAMN_ErrorTaskHandle;
uint32_t RAMN_ErrorTaskBuffer[256];
osStaticThreadDef_t RAMN_ErrorTaskControlBlock;
const osThreadAttr_t RAMN_ErrorTask_attributes = {
	.name = "RAMN_ErrorTask",
	.stack_mem = &RAMN_ErrorTaskBuffer[0],
	.stack_size = sizeof(RAMN_ErrorTaskBuffer),
	.cb_mem = &RAMN_ErrorTaskControlBlock,
	.cb_size = sizeof(RAMN_ErrorTaskControlBlock),
	.priority = (osPriority_t)osPriorityRealtime1,
};
/* Definitions for RAMN_DiagRX */
osThreadId_t RAMN_DiagRXHandle;
uint32_t RAMN_DiagRXBuffer[256];
osStaticThreadDef_t RAMN_DiagRXControlBlock;
const osThreadAttr_t RAMN_DiagRX_attributes = {
	.name = "RAMN_DiagRX",
	.stack_mem = &RAMN_DiagRXBuffer[0],
	.stack_size = sizeof(RAMN_DiagRXBuffer),
	.cb_mem = &RAMN_DiagRXControlBlock,
	.cb_size = sizeof(RAMN_DiagRXControlBlock),
	.priority = (osPriority_t)osPriorityBelowNormal,
};
/* Definitions for RAMN_DiagTX */
osThreadId_t RAMN_DiagTXHandle;
uint32_t RAMN_DiagTXBuffer[256];
osStaticThreadDef_t RAMN_DiagTXControlBlock;
const osThreadAttr_t RAMN_DiagTX_attributes = {
	.name = "RAMN_DiagTX",
	.stack_mem = &RAMN_DiagTXBuffer[0],
	.stack_size = sizeof(RAMN_DiagTXBuffer),
	.cb_mem = &RAMN_DiagTXControlBlock,
	.cb_size = sizeof(RAMN_DiagTXControlBlock),
	.priority = (osPriority_t)osPriorityLow7,
};
/* Definitions for RAMN_SendUSB */
osThreadId_t RAMN_SendUSBHandle;
const osThreadAttr_t RAMN_SendUSB_attributes = {
	.name = "RAMN_SendUSB",
	.priority = (osPriority_t)osPriorityRealtime,
	.stack_size = 256 * 4};
/* Definitions for RAMN_RxTask2 */
osThreadId_t RAMN_RxTask2Handle;
const osThreadAttr_t RAMN_RxTask2_attributes = {
	.name = "RAMN_RxTask2",
	.priority = (osPriority_t)osPriorityHigh1,
	.stack_size = 512 * 4};
/* Definitions for RAMN_TxTask2 */
osThreadId_t RAMN_TxTask2Handle;
const osThreadAttr_t RAMN_TxTask2_attributes = {
	.name = "RAMN_TxTask2",
	.priority = (osPriority_t)osPriorityHigh2,
	.stack_size = 256 * 4};
/* USER CODE BEGIN PV */

#ifdef ENABLE_GSUSB
/* Definitions for RAMN_GSUSB_RecvQueue */
osMessageQueueId_t RAMN_GSUSB_RecvQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_RecvQueueBuffer[GSUSB_RECV_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_RecvQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_RecvQueue_attributes = {
	.name = "RAMN_GSUSB_RecvQueue",
	.cb_mem = &RAMN_GSUSB_RecvQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_RecvQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_RecvQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_RecvQueueBuffer)};
/* Definitions for RAMN_GSUSB_PoolQueue */
osMessageQueueId_t RAMN_GSUSB_PoolQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_PoolQueueBuffer[GSUSB_POOL_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_PoolQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_PoolQueue_attributes = {
	.name = "RAMN_GSUSB_PoolQueue",
	.cb_mem = &RAMN_GSUSB_PoolQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_PoolQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_PoolQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_PoolQueueBuffer)};
/* Definitions for RAMN_GSUSB_SendQueue */
osMessageQueueId_t RAMN_GSUSB_SendQueueHandle;
__attribute__((section(".buffers"))) uint8_t RAMN_GSUSB_SendQueueBuffer[GSUSB_SEND_QUEUE_SIZE * sizeof(uint32_t)];
osStaticMessageQDef_t RAMN_GSUSB_SendQueueControlBlock;
const osMessageQueueAttr_t RAMN_GSUSB_SendQueue_attributes = {
	.name = "RAMN_GSUSB_SendQueue",
	.cb_mem = &RAMN_GSUSB_SendQueueControlBlock,
	.cb_size = sizeof(RAMN_GSUSB_SendQueueControlBlock),
	.mq_mem = &RAMN_GSUSB_SendQueueBuffer,
	.mq_size = sizeof(RAMN_GSUSB_SendQueueBuffer)};
#endif

#if defined(ENABLE_CDC)

// Stream buffer for USB RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t USB_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_RX_BUFFER[USB_RX_BUFFER_SIZE];
StreamBufferHandle_t USBD_RxStreamBufferHandle;

// Stream buffer for USB TX data, filled by transmitting task(s).
static StaticStreamBuffer_t USB_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t USB_TX_BUFFER[USB_TX_BUFFER_SIZE];
StreamBufferHandle_t USBD_TxStreamBufferHandle;

// Intermediary buffer to empty USB_TX_BUFFER and pass it to CDC drivers (data currently being transmitted over USB).
__attribute__((section(".buffers"))) uint8_t USBIntermediateTxBuffer[APP_TX_DATA_SIZE];

// Holds currently processed (slcan) USB command.
__attribute__((section(".buffers"))) uint8_t USBRxBuffer[USB_COMMAND_BUFFER_SIZE];

// Holds currently processed (slcan) USB command's answer (Used by CAN receiving task).
__attribute__((section(".buffers"))) uint8_t slCAN_USBTxBuffer[0x200];

#endif

#if defined(ENABLE_UART)

// Stream buffer for UART RX data, filled by ISR and emptied by receiving task.
static StaticStreamBuffer_t UART_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_RX_BUFFER[UART_RX_BUFFER_SIZE];
StreamBufferHandle_t UART_RxStreamBufferHandle;

// Stream buffer for UART TX data, filled by transmitting task(s).
static StaticStreamBuffer_t UART_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UART_TX_BUFFER[UART_TX_BUFFER_SIZE];
StreamBufferHandle_t UART_TxStreamBufferHandle;

// Holds command currently being received over UART, used by ISR
__attribute__((section(".buffers"))) static uint8_t UART_recvBuf[UART_RX_COMMAND_BUFFER_SIZE];

// Holds data currently being transmitted over UART, used as an argument to HAL library.
__attribute__((section(".buffers"))) uint8_t UARTIntermediateTxBuffer[UART_TX_COMMAND_BUFFER_SIZE];

// Holds data currently being processed, used by receiving task.
__attribute__((section(".buffers"))) uint8_t UARTRxBuffer[UART_RX_COMMAND_BUFFER_SIZE];

// Buffer to receive next UART char, used by ISR.
static uint8_t uart_rx_data[1];

// Current index of uart command.
static uint16_t uart_current_index = 0;

#endif

static RAMN_Bool_t USB_CLI_ENABLE;

#if defined(ENABLE_I2C)
__attribute__((section(".buffers"))) uint8_t i2c_rxBuf[I2C_RX_BUFFER_SIZE];
__attribute__((section(".buffers"))) uint8_t i2c_txBuf[I2C_TX_BUFFER_SIZE] = {'R', 'A', 'M', 'N'};
#endif

#if defined(ENABLE_DIAG)

// Holds currently processed Diag Command from CAN.
// Aligned to enable easy shell code execution.
__attribute__((section(".buffers"), aligned(4))) uint8_t diagRxbuf[0xFFF + 2];
// Holds currently generated Diag Command Answer for CAN.
__attribute__((section(".buffers"))) uint8_t diagTxbuf[0xFFF];

#endif

// Buffers for UDS commands, only allocated if enabled.
#if defined(ENABLE_UDS)

static StaticStreamBuffer_t UDS_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_RX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t UDS_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t UDS_ISOTP_TX_BUFFER[UDS_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for KWP commands, only allocated if enabled.
#if defined(ENABLE_KWP)

static StaticStreamBuffer_t KWP_ISOTP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_RX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t KWP_ISOTP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t KWP_ISOTP_TX_BUFFER[KWP_ISOTP_RX_BUFFER_SIZE];

#endif

// Buffers for XCP commands, only allocated if enabled.
#if defined(ENABLE_XCP)

static StaticStreamBuffer_t XCP_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_RX_BUFFER[XCP_RX_BUFFER_SIZE];

static StaticStreamBuffer_t XCP_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t XCP_TX_BUFFER[XCP_RX_BUFFER_SIZE];

#endif

// Buffers for CAN Messages.
static StaticStreamBuffer_t CAN_RX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_RX_BUFFER[CAN_RX_BUFFER_SIZE];

static StaticStreamBuffer_t CAN_TX_BUFFER_STRUCT;
__attribute__((section(".buffers"))) static uint8_t CAN_TX_BUFFER[CAN_TX_BUFFER_SIZE];

// Handle for diag stream buffers, even unallocated ones.
StreamBufferHandle_t UdsRxDataStreamBufferHandle;
StreamBufferHandle_t UdsTxDataStreamBufferHandle;

StreamBufferHandle_t KwpRxDataStreamBufferHandle;
StreamBufferHandle_t KwpTxDataStreamBufferHandle;

StreamBufferHandle_t XcpRxDataStreamBufferHandle;
StreamBufferHandle_t XcpTxDataStreamBufferHandle;

// Header for RTR answers
FDCAN_TxHeaderTypeDef RTRTxHeader;
uint8_t RTRTxData[8];

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DMA_Init(void);
static void MX_ICACHE_Init(void);
static void MX_RNG_Init(void);
static void MX_FDCAN1_Init(void);
static void MX_SPI2_Init(void);
static void MX_ADC1_Init(void);
static void MX_IWDG_Init(void);
static void MX_CRC_Init(void);
static void MX_I2C2_Init(void);
static void MX_LPUART1_UART_Init(void);
static void MX_USB_PCD_Init(void);
static void MX_TIM7_Init(void);
static void MX_TIM6_Init(void);
static void MX_TIM16_Init(void);
void RAMN_ReceiveUSBFunc(void *argument);
void RAMN_ReceiveCANFunc(void *argument);
void RAMN_SendCANFunc(void *argument);
void RAMN_PeriodicTaskFunc(void *argument);
void RAMN_ErrorTaskFunc(void *argument);
void RAMN_DiagRXFunc(void *argument);
void RAMN_DiagTXFunc(void *argument);
void RAMN_SendUSBFunc(void *argument);
void RAMN_RxTask2Func(void *argument);
void RAMN_TxTask2Func(void *argument);

/* USER CODE BEGIN PFP */
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if defined(GENERATE_RUNTIME_STATS)
volatile unsigned long ulHighFrequencyTimerTicks;

void configureTimerForRunTimeStats(void)
{
	ulHighFrequencyTimerTicks = 0U;
	HAL_TIM_Base_Start_IT(&htim7);
}

unsigned long getRunTimeCounterValue(void)
{
	return ulHighFrequencyTimerTicks;
}
#endif
/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	// Ensure proper configuration of VTOR or program does not work correctly after live booting from DFU bootloader
	__disable_irq();
	SCB->VTOR = FLASH_BASE_NS;
	__DSB();
	__enable_irq();
	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

#ifdef RENODE_SIM
	// Use normal initialization path; RENODE_SIM bypass removed
#endif

#if defined(TARGET_ECUA)
	// Check that ECU A BOOT option bytes are properly configured to hardware BOOT0, which should be pulled-up by default.
	RAMN_FLASH_ConfigureOptionBytesApplicationMode();
#endif

#if defined(MEMORY_AUTOLOCK)
	if (RAMN_FLASH_isMemoryProtected() == False)
		RAMN_FLASH_ConfigureRDPOptionByte(RDP_OPTIONBYTE);
#endif

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DMA_Init();
	MX_ICACHE_Init();
#ifndef RENODE_SIM
	MX_RNG_Init();
#endif
#ifndef RENODE_SIM
	MX_FDCAN1_Init();
#endif
	MX_SPI2_Init();
	MX_ADC1_Init();
	MX_IWDG_Init();
	MX_CRC_Init();
	MX_I2C2_Init();
	MX_LPUART1_UART_Init();
	MX_USB_PCD_Init();
	MX_TIM7_Init();
	MX_TIM6_Init();
	MX_TIM16_Init();
	/* USER CODE BEGIN 2 */

#ifdef START_IN_CLI_MODE
	USB_CLI_ENABLE = 1U;
#else
	USB_CLI_ENABLE = 0U;
#endif

#if defined(ENABLE_CDC)
	USBD_RxStreamBufferHandle = xStreamBufferCreateStatic(USB_RX_BUFFER_SIZE, sizeof(uint8_t), USB_RX_BUFFER, &USB_RX_BUFFER_STRUCT);
	USBD_TxStreamBufferHandle = xStreamBufferCreateStatic(USB_TX_BUFFER_SIZE, sizeof(uint8_t), USB_TX_BUFFER, &USB_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UART)
	UART_RxStreamBufferHandle = xStreamBufferCreateStatic(UART_RX_BUFFER_SIZE, sizeof(uint8_t), UART_RX_BUFFER, &UART_RX_BUFFER_STRUCT);
	UART_TxStreamBufferHandle = xStreamBufferCreateStatic(UART_TX_BUFFER_SIZE, sizeof(uint8_t), UART_TX_BUFFER, &UART_TX_BUFFER_STRUCT);
#endif

#if defined(ENABLE_UDS)
	UdsRxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_RX_BUFFER, &UDS_ISOTP_RX_BUFFER_STRUCT);
	UdsTxDataStreamBufferHandle = xStreamBufferCreateStatic(UDS_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), UDS_ISOTP_TX_BUFFER, &UDS_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_KWP)
	KwpRxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_RX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_RX_BUFFER, &KWP_ISOTP_RX_BUFFER_STRUCT);
	KwpTxDataStreamBufferHandle = xStreamBufferCreateStatic(KWP_ISOTP_TX_BUFFER_SIZE, sizeof(uint8_t), KWP_ISOTP_TX_BUFFER, &KWP_ISOTP_TX_BUFFER_STRUCT);
#endif
#if defined(ENABLE_XCP)
	XcpRxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_RX_BUFFER_SIZE, sizeof(uint8_t), XCP_RX_BUFFER, &XCP_RX_BUFFER_STRUCT);
	XcpTxDataStreamBufferHandle = xStreamBufferCreateStatic(XCP_TX_BUFFER_SIZE, sizeof(uint8_t), XCP_TX_BUFFER, &XCP_TX_BUFFER_STRUCT);
#endif

	CANRxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_RX_BUFFER_SIZE, sizeof(uint8_t), CAN_RX_BUFFER, &CAN_RX_BUFFER_STRUCT);
	CANTxDataStreamBufferHandle = xStreamBufferCreateStatic(CAN_TX_BUFFER_SIZE, sizeof(uint8_t), CAN_TX_BUFFER, &CAN_TX_BUFFER_STRUCT);

#if defined(TARGET_ECUA)
	// Make sure other ECUs are turned off.
	RAMN_ECU_SetEnableAll(0U);
	// Make sure BOOT0 is low (application mode).
	RAMN_ECU_SetBoot0All(0U);
#endif

#if defined(ENABLE_SPI) && !defined(ENABLE_SCREEN) // if screen is enabled, we initialize it in the screen module.
	RAMN_SPI_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

#if defined(ENABLE_EEPROM_EMULATION)
	RAMN_EEPROM_Init();
#endif

#if defined(ENABLE_DIAG)
	RAMN_DIAG_Init(xTaskGetTickCount(), &RAMN_DiagRXHandle, &UdsRxDataStreamBufferHandle, &KwpRxDataStreamBufferHandle, &XcpRxDataStreamBufferHandle);
#endif

#ifndef RENODE_SIM
	RAMN_RNG_Init(&hrng);
#endif
	RAMN_CRC_Init(&hcrc);
#ifndef RENODE_SIM
	RAMN_FDCAN_Init(&hfdcan1, &RAMN_SendCANHandle, &RAMN_ErrorTaskHandle);
#endif

#ifdef USE_TRNG_BUFFER
	// Enable TRNG module
	if (HAL_RNG_GenerateRandomNumber_IT(&hrng) != HAL_OK)
	{
#ifdef HANG_ON_ERRORS
		Error_Handler();
#endif
	}
#endif

	// Automatically add a DTC if none is stored in memory
#ifdef ENABLE_EEPROM_EMULATION
	uint32_t dtcCnt = 0U;

	if (RAMN_DTC_GetNumberOfDTC(&dtcCnt) == RAMN_OK)
	{
		if (dtcCnt == 0U)
		{
			// No DTC, add one per ECU
#ifdef TARGET_ECUA
			uint32_t dtcVal = 0b11 << 30; // "11" for network ("U")
			dtcVal |= 0x0029 << 16;		  // Bus A Performance, FTB 0
#elif defined(TARGET_ECUB)
			uint32_t dtcVal = 0b01 << 30; // "01" for chassis ("C")
			dtcVal |= 0x0563 << 16;		  // Calibration ROM Checksum Error, FTB 0
#elif defined(TARGET_ECUC)
			uint32_t dtcVal = 0b00 << 30; // "00" for powertrain ("P")
			dtcVal |= 0x0172 << 16;		  // System too Rich, FTB 0
#elif defined(TARGET_ECUD)
			uint32_t dtcVal = 0b10 << 30; // "10" for body ("B")
			dtcVal |= 0x0091 << 16;		  // Active switch wrong state, FTB 0
#endif

			dtcVal |= 1 << 2; // mark DTC as pending.
			RAMN_DTC_AddNew(dtcVal);
		}
	}
#endif
	/* USER CODE END 2 */

	/* Init scheduler */
	osKernelInitialize();

	/* USER CODE BEGIN RTOS_MUTEX */
	/* add mutexes, ... */
	/* USER CODE END RTOS_MUTEX */

	/* USER CODE BEGIN RTOS_SEMAPHORES */

	/* USER CODE END RTOS_SEMAPHORES */

	/* USER CODE BEGIN RTOS_TIMERS */
	/* start timers, add new ones, ... */
	/* USER CODE END RTOS_TIMERS */

	/* USER CODE BEGIN RTOS_QUEUES */
#ifdef ENABLE_GSUSB
	/* creation of RAMN_GSUSB_RecvQueue */
	RAMN_GSUSB_RecvQueueHandle = osMessageQueueNew(GSUSB_RECV_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_RecvQueue_attributes);

	/* creation of RAMN_GSUSB_PoolQueue */
	RAMN_GSUSB_PoolQueueHandle = osMessageQueueNew(GSUSB_POOL_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_PoolQueue_attributes);

	/* creation of RAMN_GSUSB_SendQueue */
	RAMN_GSUSB_SendQueueHandle = osMessageQueueNew(GSUSB_SEND_QUEUE_SIZE, sizeof(uint32_t), &RAMN_GSUSB_SendQueue_attributes);
#endif

#ifdef ENABLE_USB
	MX_USB_Device_Init();
#endif
	/* USER CODE END RTOS_QUEUES */

	/* Create the thread(s) */
	/* creation of RAMN_ReceiveUSB */
	RAMN_ReceiveUSBHandle = osThreadNew(RAMN_ReceiveUSBFunc, NULL, &RAMN_ReceiveUSB_attributes);

	/* creation of RAMN_ReceiveCAN */
	RAMN_ReceiveCANHandle = osThreadNew(RAMN_ReceiveCANFunc, NULL, &RAMN_ReceiveCAN_attributes);

	/* creation of RAMN_SendCAN */
	RAMN_SendCANHandle = osThreadNew(RAMN_SendCANFunc, NULL, &RAMN_SendCAN_attributes);

	/* creation of RAMN_Periodic */
	RAMN_PeriodicHandle = osThreadNew(RAMN_PeriodicTaskFunc, NULL, &RAMN_Periodic_attributes);

	/* creation of RAMN_ErrorTask */
	RAMN_ErrorTaskHandle = osThreadNew(RAMN_ErrorTaskFunc, NULL, &RAMN_ErrorTask_attributes);

	/* creation of RAMN_DiagRX */
	RAMN_DiagRXHandle = osThreadNew(RAMN_DiagRXFunc, NULL, &RAMN_DiagRX_attributes);

	/* creation of RAMN_DiagTX */
	RAMN_DiagTXHandle = osThreadNew(RAMN_DiagTXFunc, NULL, &RAMN_DiagTX_attributes);

	/* creation of RAMN_SendUSB */
	RAMN_SendUSBHandle = osThreadNew(RAMN_SendUSBFunc, NULL, &RAMN_SendUSB_attributes);

	/* creation of RAMN_RxTask2 */
	RAMN_RxTask2Handle = osThreadNew(RAMN_RxTask2Func, NULL, &RAMN_RxTask2_attributes);

	/* creation of RAMN_TxTask2 */
	RAMN_TxTask2Handle = osThreadNew(RAMN_TxTask2Func, NULL, &RAMN_TxTask2_attributes);

	/* USER CODE BEGIN RTOS_THREADS */

	/* USER CODE END RTOS_THREADS */

	/* USER CODE BEGIN RTOS_EVENTS */
	/* add events, ... */
	/* USER CODE END RTOS_EVENTS */

	/* Start scheduler */
	osKernelStart();

	/* We should never get here as control is now taken by the scheduler */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	/* Bypass complex clock init on Renode to avoid HAL errors */
#ifdef RENODE_SIM
	return;
#endif
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
	RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
	RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
	RCC_OscInitStruct.LSIState = RCC_LSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
	RCC_OscInitStruct.PLL.PLLN = 16;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV4;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
	{
		Error_Handler();
	}

	/** Enable the SYSCFG APB clock
	 */
	__HAL_RCC_CRS_CLK_ENABLE();

	/** Configures CRS
	 */
	RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
	RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
	RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
	RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
	RCC_CRSInitStruct.ErrorLimitValue = 34;
	RCC_CRSInitStruct.HSI48CalibrationValue = 32;

	HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
}

/**
 * @brief ADC1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_ADC1_Init(void)
{

	/* USER CODE BEGIN ADC1_Init 0 */
#ifdef ENABLE_ADC
	/* USER CODE END ADC1_Init 0 */

	ADC_MultiModeTypeDef multimode = {0};
	ADC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN ADC1_Init 1 */

	/* USER CODE END ADC1_Init 1 */

	/** Common config
	 */
	hadc1.Instance = ADC1;
	hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV256;
	hadc1.Init.Resolution = ADC_RESOLUTION_12B;
	hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
	hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
	hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
	hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = ENABLE;
	hadc1.Init.NbrOfConversion = 3;
	hadc1.Init.DiscontinuousConvMode = DISABLE;
	hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
	hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
	hadc1.Init.DMAContinuousRequests = ENABLE;
	hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
	hadc1.Init.OversamplingMode = DISABLE;
	if (HAL_ADC_Init(&hadc1) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure the ADC multi-mode
	 */
	multimode.Mode = ADC_MODE_INDEPENDENT;
	if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_6;
	sConfig.Rank = ADC_REGULAR_RANK_1;
	sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
	sConfig.SingleDiff = ADC_SINGLE_ENDED;
	sConfig.OffsetNumber = ADC_OFFSET_NONE;
	sConfig.Offset = 0;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_9;
	sConfig.Rank = ADC_REGULAR_RANK_2;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Regular Channel
	 */
	sConfig.Channel = ADC_CHANNEL_10;
	sConfig.Rank = ADC_REGULAR_RANK_3;
	if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ADC1_Init 2 */
#endif
	/* USER CODE END ADC1_Init 2 */
}

/**
 * @brief CRC Initialization Function
 * @param None
 * @retval None
 */
static void MX_CRC_Init(void)
{

	/* USER CODE BEGIN CRC_Init 0 */

	/* USER CODE END CRC_Init 0 */

	/* USER CODE BEGIN CRC_Init 1 */

	/* USER CODE END CRC_Init 1 */
	hcrc.Instance = CRC;
	hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
	hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
	hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
	hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
	hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
	if (HAL_CRC_Init(&hcrc) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN CRC_Init 2 */

	/* USER CODE END CRC_Init 2 */
}

/**
 * @brief FDCAN1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_FDCAN1_Init(void)
{

	/* USER CODE BEGIN FDCAN1_Init 0 */

	/* USER CODE END FDCAN1_Init 0 */

	/* USER CODE BEGIN FDCAN1_Init 1 */

	/* USER CODE END FDCAN1_Init 1 */
	hfdcan1.Instance = FDCAN1;
	hfdcan1.Init.ClockDivider = FDCAN_CLOCK_DIV1;
	hfdcan1.Init.FrameFormat = FDCAN_FRAME_FD_BRS;
	hfdcan1.Init.Mode = FDCAN_MODE_NORMAL;
	hfdcan1.Init.AutoRetransmission = ENABLE;
	hfdcan1.Init.TransmitPause = DISABLE;
	hfdcan1.Init.ProtocolException = DISABLE;
	hfdcan1.Init.NominalPrescaler = 1;
	hfdcan1.Init.NominalSyncJumpWidth = 16;
	hfdcan1.Init.NominalTimeSeg1 = 60;
	hfdcan1.Init.NominalTimeSeg2 = 19;
	hfdcan1.Init.DataPrescaler = 1;
	hfdcan1.Init.DataSyncJumpWidth = 16;
	hfdcan1.Init.DataTimeSeg1 = 15;
	hfdcan1.Init.DataTimeSeg2 = 4;
	hfdcan1.Init.StdFiltersNbr = 1;
	hfdcan1.Init.ExtFiltersNbr = 1;
	hfdcan1.Init.TxFifoQueueMode = FDCAN_TX_FIFO_OPERATION;
	if (HAL_FDCAN_Init(&hfdcan1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN FDCAN1_Init 2 */

	/* USER CODE END FDCAN1_Init 2 */
}

/**
 * @brief I2C2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_I2C2_Init(void)
{

	/* USER CODE BEGIN I2C2_Init 0 */
#ifdef ENABLE_I2C
	/* USER CODE END I2C2_Init 0 */

	/* USER CODE BEGIN I2C2_Init 1 */

	/* USER CODE END I2C2_Init 1 */
	hi2c2.Instance = I2C2;
	hi2c2.Init.Timing = 0x10D19CE4;
	hi2c2.Init.OwnAddress1 = 238;
	hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c2.Init.OwnAddress2 = 0;
	hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
	if (HAL_I2C_Init(&hi2c2) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Analogue filter
	 */
	if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
	{
		Error_Handler();
	}

	/** Configure Digital filter
	 */
	if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN I2C2_Init 2 */
#endif
	/* USER CODE END I2C2_Init 2 */
}

/**
 * @brief ICACHE Initialization Function
 * @param None
 * @retval None
 */
static void MX_ICACHE_Init(void)
{

	/* USER CODE BEGIN ICACHE_Init 0 */

	/* USER CODE END ICACHE_Init 0 */

	/* USER CODE BEGIN ICACHE_Init 1 */

	/* USER CODE END ICACHE_Init 1 */

	/** Enable instruction cache in 1-way (direct mapped cache)
	 */
	if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_ICACHE_Enable() != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN ICACHE_Init 2 */

	/* USER CODE END ICACHE_Init 2 */
}

/**
 * @brief IWDG Initialization Function
 * @param None
 * @retval None
 */
static void MX_IWDG_Init(void)
{

	/* USER CODE BEGIN IWDG_Init 0 */
#ifdef WATCHDOG_ENABLE
	/* USER CODE END IWDG_Init 0 */

	/* USER CODE BEGIN IWDG_Init 1 */

	/* USER CODE END IWDG_Init 1 */
	hiwdg.Instance = IWDG;
	hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
	hiwdg.Init.Window = 4095;
	hiwdg.Init.Reload = 1000;
	if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN IWDG_Init 2 */
#endif
	/* USER CODE END IWDG_Init 2 */
}

/**
 * @brief LPUART1 Initialization Function
 * @param None
 * @retval None
 */
static void MX_LPUART1_UART_Init(void)
{

	/* USER CODE BEGIN LPUART1_Init 0 */
#ifdef ENABLE_UART
/* USER CODE END LPUART1_Init 0 */

/* USER CODE BEGIN LPUART1_Init 1 */

/* USER CODE END LPUART1_Init 1 */
#ifdef RENODE_SIM
	hlpuart1.Instance = USART1; // Use USART1 under Renode for better peripheral model support
#else
	hlpuart1.Instance = LPUART1;
#endif
	hlpuart1.Init.BaudRate = 115200;
	hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
	hlpuart1.Init.StopBits = UART_STOPBITS_1;
	hlpuart1.Init.Parity = UART_PARITY_NONE;
	hlpuart1.Init.Mode = UART_MODE_TX_RX;
	hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
	hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
	hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
	hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;
    #ifndef RENODE_SIM
    if (HAL_UART_Init(&hlpuart1) != HAL_OK)
    {
        Error_Handler();
    }
    #else
    (void)HAL_UART_Init(&hlpuart1); // On Renode, ignore return to avoid Error_Handler
    #endif
#ifndef RENODE_SIM
	if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
	{
		Error_Handler();
	}
	if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
	{
		Error_Handler();
	}
#endif
	/* USER CODE BEGIN LPUART1_Init 2 */
#endif
	/* USER CODE END LPUART1_Init 2 */
}

/**
 * @brief RNG Initialization Function
 * @param None
 * @retval None
 */
static void MX_RNG_Init(void)
{

	/* USER CODE BEGIN RNG_Init 0 */

	/* USER CODE END RNG_Init 0 */

	/* USER CODE BEGIN RNG_Init 1 */

	/* USER CODE END RNG_Init 1 */
	hrng.Instance = RNG;
	hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
	if (HAL_RNG_Init(&hrng) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN RNG_Init 2 */

	/* USER CODE END RNG_Init 2 */
}

/**
 * @brief SPI2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_SPI2_Init(void)
{

	/* USER CODE BEGIN SPI2_Init 0 */
#ifdef ENABLE_SPI
	/* USER CODE END SPI2_Init 0 */

	/* USER CODE BEGIN SPI2_Init 1 */

	/* USER CODE END SPI2_Init 1 */
	/* SPI2 parameter configuration*/
	hspi2.Instance = SPI2;
	hspi2.Init.Mode = SPI_MODE_MASTER;
	hspi2.Init.Direction = SPI_DIRECTION_2LINES;
	hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
	hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
	hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
	hspi2.Init.NSS = SPI_NSS_SOFT;
	hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
	hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
	hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
	hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
	hspi2.Init.CRCPolynomial = 7;
	hspi2.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
	hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
	if (HAL_SPI_Init(&hspi2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN SPI2_Init 2 */
#endif
	/* USER CODE END SPI2_Init 2 */
}

/**
 * @brief TIM6 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM6_Init(void)
{

	/* USER CODE BEGIN TIM6_Init 0 */

	/* USER CODE END TIM6_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM6_Init 1 */

	/* USER CODE END TIM6_Init 1 */
	htim6.Instance = TIM6;
	htim6.Init.Prescaler = 9999;
	htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim6.Init.Period = 7999;
	htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM6_Init 2 */

	/* USER CODE END TIM6_Init 2 */
}

/**
 * @brief TIM7 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM7_Init(void)
{

	/* USER CODE BEGIN TIM7_Init 0 */
#ifdef GENERATE_RUNTIME_STATS
	/* USER CODE END TIM7_Init 0 */

	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM7_Init 1 */

	/* USER CODE END TIM7_Init 1 */
	htim7.Instance = TIM7;
	htim7.Init.Prescaler = 0;
	htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim7.Init.Period = 7999;
	htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM7_Init 2 */
#endif
	/* USER CODE END TIM7_Init 2 */
}

/**
 * @brief TIM16 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM16_Init(void)
{

	/* USER CODE BEGIN TIM16_Init 0 */

	/* USER CODE END TIM16_Init 0 */

	/* USER CODE BEGIN TIM16_Init 1 */

	/* USER CODE END TIM16_Init 1 */
	htim16.Instance = TIM16;
	htim16.Init.Prescaler = 79;
	htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim16.Init.Period = 65535;
	htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim16.Init.RepetitionCounter = 0;
	htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM16_Init 2 */

	/* USER CODE END TIM16_Init 2 */
}

/**
 * @brief USB Initialization Function
 * @param None
 * @retval None
 */
static void MX_USB_PCD_Init(void)
{

	/* USER CODE BEGIN USB_Init 0 */

	/* USER CODE END USB_Init 0 */

	/* USER CODE BEGIN USB_Init 1 */

	/* USER CODE END USB_Init 1 */
	hpcd_USB_FS.Instance = USB;
	hpcd_USB_FS.Init.dev_endpoints = 8;
	hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
	hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
	hpcd_USB_FS.Init.Sof_enable = DISABLE;
	hpcd_USB_FS.Init.low_power_enable = DISABLE;
	hpcd_USB_FS.Init.lpm_enable = DISABLE;
	hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
	if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USB_Init 2 */

	/* USER CODE END USB_Init 2 */
}

/**
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void)
{

	/* DMA controller clock enable */
	__HAL_RCC_DMAMUX1_CLK_ENABLE();
	__HAL_RCC_DMA1_CLK_ENABLE();
	__HAL_RCC_DMA2_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
	/* DMA1_Channel2_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
	/* DMA2_Channel1_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA2_Channel1_IRQn, 5, 0);
	HAL_NVIC_EnableIRQ(DMA2_Channel1_IRQn);
}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */
	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC, ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, ECUD_EN_Pin | Other_nCS_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pins : ECUC_EN_Pin ECUC_BOOT0_Pin ECUD_BOOT0_Pin */
	GPIO_InitStruct.Pin = ECUC_EN_Pin | ECUC_BOOT0_Pin | ECUD_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pins : ECUD_EN_Pin Other_nCS_Pin */
	GPIO_InitStruct.Pin = ECUD_EN_Pin | Other_nCS_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pins : LCD_nCS_Pin LCD_DC_Pin ECUB_EN_Pin FDCAN1_STB_Pin
							 ECUB_BOOT0_Pin */
	GPIO_InitStruct.Pin = LCD_nCS_Pin | LCD_DC_Pin | ECUB_EN_Pin | FDCAN1_STB_Pin | ECUB_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/*Configure GPIO pin : SELF_BOOT0_Pin */
	GPIO_InitStruct.Pin = SELF_BOOT0_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(SELF_BOOT0_GPIO_Port, &GPIO_InitStruct);

	/* USER CODE BEGIN MX_GPIO_Init_2 */
	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

#ifdef ENABLE_I2C

void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		RAMN_CUSTOM_ReceiveI2C(i2c_rxBuf, I2C_RX_BUFFER_SIZE);
	}
}

void HAL_I2C_SlaveTxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
	}
}

void HAL_I2C_AddrCallback(I2C_HandleTypeDef *hi2c, uint8_t transferDirect, uint16_t AddrMatchCode)
{
	if (hi2c != 0U)
	{
		if (transferDirect == I2C_DIRECTION_TRANSMIT)
		{
			if (HAL_I2C_Slave_Sequential_Receive_IT(hi2c, i2c_rxBuf, I2C_RX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else if (transferDirect == I2C_DIRECTION_RECEIVE)
		{
			RAMN_CUSTOM_PrepareTransmitDataI2C(i2c_txBuf, I2C_TX_BUFFER_SIZE);
			if (HAL_I2C_Slave_Sequential_Transmit_IT(hi2c, i2c_txBuf, I2C_TX_BUFFER_SIZE, I2C_FIRST_AND_LAST_FRAME) != HAL_OK)
				Error_Handler();
		}
		else
			Error_Handler();
	}
}

void HAL_I2C_ListenCpltCallback(I2C_HandleTypeDef *hi2c)
{
	if (hi2c != 0)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
}

void HAL_I2C_ErrorCallback(I2C_HandleTypeDef *hi2c)
{
	uint32_t err = HAL_I2C_GetError(hi2c);

	// if (err != HAL_I2C_ERROR_AF)
	if (err != HAL_I2C_ERROR_NONE)
	{
		HAL_I2C_EnableListen_IT(hi2c);
	}
	else
	{
		// Error_Handler();
	}
}

#endif

#ifdef ENABLE_UART

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
	// End of transmit
	if (RAMN_SendUSBHandle != NULL)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		vTaskNotifyGiveFromISR(RAMN_SendUSBHandle, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	// TODO: better error reporting
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
	if (uart_current_index >= sizeof(UART_recvBuf))
	{
		uart_current_index = 0;
	}
	else if (uart_rx_data[0] != '\r')
	{
		UART_recvBuf[uart_current_index] = uart_rx_data[0];
		uart_current_index++;
	}
	else
	{
		if ((uart_current_index > 0) && (uart_current_index <= sizeof(UART_recvBuf))) // Don't forward empty commands or commands longer than buffer
		{
			if (UART_RxStreamBufferHandle != NULL)
			{

				if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, &uart_current_index, 2U, NULL) != 2U)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler()
#endif
				}
				else
				{
					if (xStreamBufferSendFromISR(UART_RxStreamBufferHandle, UART_recvBuf, uart_current_index, NULL) != uart_current_index)
					{
#ifdef HANG_ON_ERRORS
						Error_Handler()
#endif
					}
					else
					{
						vTaskNotifyGiveFromISR(RAMN_ReceiveUSBHandle, &xHigherPriorityTaskWoken);
						portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
					}
				}
			}
		}
		uart_current_index = 0;
	}
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1);
}
#endif

/* USER CODE END 4 */

/* USER CODE BEGIN Header_RAMN_ReceiveUSBFunc */
/**
 * @brief  Function implementing the RAMN_ReceiveUSB thread.
 * @param  argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveUSBFunc */
void RAMN_ReceiveUSBFunc(void *argument)
{
	/* USER CODE BEGIN 5 */
#if defined(ENABLE_CDC)
	/* init code for USB_Device */
	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		RAMN_Bool_t invalidBuffer = False;

		xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if ((xBytesReceived != 2U) || (commandLength > USB_COMMAND_BUFFER_SIZE))
			invalidBuffer = True;
		else
		{
			xBytesReceived = xStreamBufferReceive(USBD_RxStreamBufferHandle, (void *)USBRxBuffer, commandLength, portMAX_DELAY);
			if (xBytesReceived != commandLength)
				invalidBuffer = True;
		}

		if (invalidBuffer == True)
		{
			// Error counter should already have been increased by CDC_Receive_FS
			if (USB_CLI_ENABLE == True)
				RAMN_USB_SendStringFromTask("Error processing USB Buffer.\r");
			else
				RAMN_USB_SendFromTask((uint8_t *)"\a", 1U);
			continue;
		}

		if (RAMN_CUSTOM_ProcessCDCLine(USBRxBuffer, commandLength) == False) // If not asked to skip
		{
			if (USB_CLI_ENABLE == True)
			{
				if (RAMN_CDC_ProcessCLIBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
			else
			{
				if (RAMN_CDC_ProcessSLCANBuffer(USBRxBuffer, commandLength) == True)
					USB_CLI_ENABLE = !USB_CLI_ENABLE;
			}
		}
	}
#elif defined(ENABLE_UART)
	HAL_UART_Receive_IT(&hlpuart1, &uart_rx_data, 1); // Start receiving characters, one by one by default (slow)

	for (;;)
	{
		uint16_t commandLength;
		size_t xBytesReceived;
		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)&commandLength, 2U, portMAX_DELAY);
		if (xBytesReceived != 2U)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		xBytesReceived = xStreamBufferReceive(UART_RxStreamBufferHandle, (void *)UARTRxBuffer, commandLength, portMAX_DELAY);
		if (xBytesReceived != commandLength)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

		RAMN_CUSTOM_ReceiveUART(UARTRxBuffer, commandLength);
	}
#else
	RAMN_CUSTOM_CustomTask1(argument);
#endif
	/* USER CODE END 5 */
}

/* USER CODE BEGIN Header_RAMN_ReceiveCANFunc */
/**
 * @brief Function implementing the RAMN_ReceiveCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ReceiveCANFunc */
void RAMN_ReceiveCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ReceiveCANFunc */
	FDCAN_RxHeaderTypeDef CANRxHeader;
	uint8_t CANRxData[64U];

	for (;;)
	{
		if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)&CANRxHeader, sizeof(CANRxHeader), portMAX_DELAY) == sizeof(CANRxHeader))
		{
			uint8_t payloadSize = DLCtoUINT8(CANRxHeader.DataLength);
			if (payloadSize > 0)
			{
				if (xStreamBufferReceive(CANRxDataStreamBufferHandle, (void *)CANRxData, payloadSize, portMAX_DELAY) != payloadSize)
				{
#ifdef HANG_ON_ERRORS
					Error_Handler();
#endif
				}
			}

			if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_DBC_ProcessCANMessage(CANRxHeader.Identifier, payloadSize, (RAMN_CANFrameData_t *)CANRxData);
#if defined(ENABLE_DIAG)
				RAMN_DIAG_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
#if defined(ENABLE_SCREEN)
				RAMN_SCREENMANAGER_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			}
#ifdef RTR_DEMO_ID
			else if (CANRxHeader.RxFrameType == FDCAN_REMOTE_FRAME)
			{

				if (CANRxHeader.Identifier == RTR_DEMO_ID)
				{
					RTRTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
					RTRTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
					RTRTxHeader.TxFrameType = FDCAN_DATA_FRAME;
					RTRTxHeader.IdType = CANRxHeader.IdType;
					RTRTxHeader.Identifier = CANRxHeader.Identifier;
					RTRTxHeader.DataLength = CANRxHeader.DataLength;
					if (RTRTxHeader.DataLength > 8U)
						RTRTxHeader.DataLength = 8U;
					RAMN_memcpy((uint8_t *)RTRTxData, (uint8_t *)HARDWARE_UNIQUE_ID_ADDRESS, 8); // Copy 8 last bytes of ECU hardware ID
					RAMN_FDCAN_SendMessage(&RTRTxHeader, RTRTxData);
				}
			}
#endif

#if defined(ENABLE_MINICTF) && defined(TARGET_ECUD)
			RAMN_CTF_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());
#endif
			RAMN_CUSTOM_ProcessRxCANMessage(&CANRxHeader, CANRxData, xTaskGetTickCount());

#if defined(ENABLE_CDC)
			if (RAMN_USB_Config.slcanOpened)
			{
				uint8_t index = 0;

				// Add prefix if frame is of CAN-FD type
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					if (CANRxHeader.BitRateSwitch == FDCAN_BRS_ON)
						slCAN_USBTxBuffer[index++] = '1';
					else
						slCAN_USBTxBuffer[index++] = '0';
				}
				else
				{
					if (payloadSize > 8U)
						payloadSize = 8U;
				}

				if (CANRxHeader.RxFrameType == FDCAN_DATA_FRAME)
				{
					// Message with Data
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 't' : 'T';
				}
				else
				{
					// FDCAN_REMOTE_FRAME is the only other option
					slCAN_USBTxBuffer[index++] = CANRxHeader.IdType == FDCAN_STANDARD_ID ? 'r' : 'R';
					payloadSize = 0; // no payload will be sent.
				}

				if (CANRxHeader.IdType == FDCAN_STANDARD_ID)
				{
					// Standard ID (FDCAN_STANDARD_ID)
					index += uint12toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					// Extended ID (FDCAN_EXTENDED_ID)
					index += uint32toASCII(CANRxHeader.Identifier, &slCAN_USBTxBuffer[index]);
				}

				// TODO: unify
				if (CANRxHeader.FDFormat == FDCAN_FD_CAN)
				{
					index += uint4toASCII((CANRxHeader.DataLength) & 0xF, &slCAN_USBTxBuffer[index]);
				}
				else
				{
					index += uint4toASCII((payloadSize) & 0xF, &slCAN_USBTxBuffer[index]);
				}

				for (uint8_t i = 0; i < payloadSize; i++)
				{
					index += uint8toASCII(CANRxData[i], &slCAN_USBTxBuffer[index]);
				}

				if (RAMN_USB_Config.slcan_enableTimestamp != 0U)
				{
					index += uint16toASCII(xTaskGetTickCount() % 0xEA60, &slCAN_USBTxBuffer[index]);
				}

				if ((RAMN_USB_Config.addESIFlag != 0U) && (CANRxHeader.FDFormat == FDCAN_FD_CAN) && (CANRxHeader.ErrorStateIndicator == FDCAN_ESI_PASSIVE))
				{
					slCAN_USBTxBuffer[index++] = 'i';
				}
				slCAN_USBTxBuffer[index++] = '\r';
				if (RAMN_USB_SendFromTask(slCAN_USBTxBuffer, index) != RAMN_OK)
				{
#ifdef CLOSE_DEVICE_ON_USB_TX_OVERFLOW
					// USB overflow, user probably forgot to close the device
					RAMN_USB_Config.slcanOpened = False;
#endif
				}
			}
#endif

#ifdef ENABLE_GSUSB
			if (RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef *)hpcd_USB_FS.pData))
			{
				if (RAMN_GSUSB_ProcessRX(&CANRxHeader, CANRxData) == RAMN_ERROR)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
#endif
		}
		else
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
	}
	/* USER CODE END RAMN_ReceiveCANFunc */
}

/* USER CODE BEGIN Header_RAMN_SendCANFunc */
/**
 * @brief Function implementing the RAMN_SendCAN thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendCANFunc */
void RAMN_SendCANFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendCANFunc */
	/* Infinite loop */
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];
	uint8_t payloadSize;
	/* Infinite loop */
	for (;;)
	{
		uint32_t index = 0;
		while (index < sizeof(CANTxHeader))
		{
			index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(&CANTxHeader + index), sizeof(CANTxHeader) - index, portMAX_DELAY);
		}
		payloadSize = DLCtoUINT8(CANTxHeader.DataLength);
		if (CANTxHeader.TxFrameType == FDCAN_REMOTE_FRAME)
			payloadSize = 0U; // No payload for remote requests
		if (payloadSize > 0U)
		{
			index = 0U;
			while (index < payloadSize)
				index += xStreamBufferReceive(CANTxDataStreamBufferHandle, (void *)(CANTxData + index), payloadSize - index, portMAX_DELAY);
		}

		// Wait for TX space to be available in FIFO
		while (HAL_FDCAN_GetTxFifoFreeLevel(&hfdcan1) < 1)
		{
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}

		if (HAL_FDCAN_AddMessageToTxFifoQ(&hfdcan1, &CANTxHeader, CANTxData) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}

#ifdef ENABLE_GSUSB
		/* echo transmission
		if(RAMN_USB_Config.gsusbOpened && GSUSB_IsConnected((USBD_HandleTypeDef*)hpcd_USB_FS.pData))
		{
			// Wait for queue empty
			while (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) < FDCAN_GetQueueSize())
			{
				ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
			}
			RAMN_SocketCAN_SendTX(&CANTxHeader, CANTxData);
		}
		 */
#endif

		RAMN_FDCAN_Status.CANTXRequestCnt++;
	}
	/* USER CODE END RAMN_SendCANFunc */
}

/* USER CODE BEGIN Header_RAMN_PeriodicTaskFunc */
/**
 * @brief Function implementing the RAMN_Periodic thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_PeriodicTaskFunc */
void RAMN_PeriodicTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_PeriodicTaskFunc */
	RAMN_DBC_Init();
	RAMN_FDCAN_ResetPeripheral();

#if defined(TARGET_ECUA)
	RAMN_ECU_SetDefaultState();
#endif

#ifdef ENABLE_I2C
	if (HAL_I2C_EnableListen_IT(&hi2c2) != HAL_OK)
		Error_Handler();
#endif

#ifdef ENABLE_ADC
	HAL_ADC_Start_DMA(&hadc1, (uint32_t *)RAMN_SENSORS_ADCValues, NUMBER_OF_ADC);
	RAMN_SENSORS_Init();
#endif
	RAMN_ACTUATORS_Init();
	RAMN_SIM_Init();
#ifdef ENABLE_MINICTF
	RAMN_CTF_Init(xTaskGetTickCount());
#endif
	RAMN_CUSTOM_Init(xTaskGetTickCount());
	HAL_TIM_Base_Start_IT(&htim6); // Enable custom function timer
	HAL_TIM_Base_Start(&htim16);   // Enable custom measurement timer

#if defined(ENABLE_SCREEN)
	RAMN_SCREENMANAGER_Init(&hspi2, &RAMN_PeriodicHandle);
#endif

	// Init joystick for screen controls
#ifdef ENABLE_JOYSTICK_CONTROLS
	RAMN_Joystick_Init();
#endif

	/* Infinite loop */
	for (;;)
	{
		TickType_t xLastWakeTime;
		xLastWakeTime = xTaskGetTickCount();
#ifdef WATCHDOG_ENABLE
		if (HAL_IWDG_Refresh(&hiwdg) != HAL_OK)
		{
#ifdef HANG_ON_ERRORS
			Error_Handler();
#endif
		}
#endif
		RAMN_SENSORS_Update(xLastWakeTime);
		RAMN_SIM_UpdatePeriodic(xLastWakeTime);
		RAMN_ACTUATORS_ApplyControls(xLastWakeTime);
		if (RAMN_DBC_RequestSilence == 0U)
		{
			RAMN_DBC_Send(xLastWakeTime);
#ifdef ENABLE_MINICTF
			RAMN_CTF_Update(xLastWakeTime);
#endif
		}
		RAMN_CUSTOM_Update(xLastWakeTime);

#if defined(ENABLE_DIAG)
		RAMN_DIAG_Update(xLastWakeTime);
#endif

#ifdef ENABLE_SCREEN
		RAMN_SCREENMANAGER_Update(xLastWakeTime);
#endif

		vTaskDelayUntil(&xLastWakeTime, SIM_LOOP_CLOCK_MS);

#if defined(ENABLE_USB) && defined(ENABLE_USB_AUTODETECT)
		if (RAMN_USB_Config.serialOpened == False)
		{
			RAMN_USB_Config.simulatorActive = False;
			RAMN_DBC_RequestSilence = True;
		}
#endif
	}
	/* USER CODE END RAMN_PeriodicTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_ErrorTaskFunc */
/**
 * @brief Function implementing the RAMN_ErrorTask thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_ErrorTaskFunc */
void RAMN_ErrorTaskFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_ErrorTaskFunc */
	/* Infinite loop */
	// TODO: report Errors to GS_USB
	FDCAN_ErrorCountersTypeDef errorCount;
	FDCAN_ProtocolStatusTypeDef protocolStatus;
	RAMN_FDCAN_Status_t gw_freeze;
	uint32_t err;

	for (;;)
	{
		ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		// Read all data in a critical section for consistent readings
		taskENTER_CRITICAL();
		err = HAL_FDCAN_GetError(&hfdcan1);
		HAL_FDCAN_GetProtocolStatus(&hfdcan1, &protocolStatus);
		HAL_FDCAN_GetErrorCounters(&hfdcan1, &errorCount);
		RAMN_FDCAN_Status.prevCANError = err;
		gw_freeze = RAMN_FDCAN_Status;
		// Clear the errorCode manually
		hfdcan1.ErrorCode = HAL_FDCAN_ERROR_NONE;

		// It seems there is a bug with HAL calling this interrupt infinitely because of auto-retransmission, prevent getting stuck
		// TODO find better fix
		if ((gw_freeze.CANErrCnt > 0x20000) && ((RAMN_FDCAN_Status.prevCANError & FDCAN_IR_PEA) != 0U))
		{
			RAMN_FDCAN_Status.busOff = True;
			RAMN_FDCAN_Disable();
		}

		taskEXIT_CRITICAL();

#if defined(ENABLE_USB) && defined(ENABLE_USB_DEBUG)
		if (RAMN_DEBUG_ENABLE == True)
			RAMN_DEBUG_PrintCANError(&errorCount, &protocolStatus, &gw_freeze, err);
#endif

#ifdef ENABLE_USB
		if (err & HAL_FDCAN_ERROR_PROTOCOL_DATA)
			RAMN_FDCAN_Status.slcanFlags |= SLCAN_FLAG_BUS_ERROR;
#endif

#if defined(AUTO_RECOVER_BUSOFF)
		if (protocolStatus.BusOff != 0U)
		{
			osDelay(100);
			RAMN_FDCAN_ResetPeripheral();
		}
#endif

		// If a transmission failed, the "transmission complete" notification will not be sent. We may need to wake up the CAN send thread (?) TODO: check
		// Normally, we should only require it if protocolStatus.Activity == FDCAN_COM_STATE_TX, but it is safer to notify the thread whatever the error is.
		/* if (protocolStatus.Activity == FDCAN_COM_STATE_TX) */
		xTaskNotifyGive(RAMN_SendCANHandle);
	}
	/* USER CODE END RAMN_ErrorTaskFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagRXFunc */
/**
 * @brief Function implementing the RAMN_DiagRX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagRXFunc */
void RAMN_DiagRXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagRXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask5(argument);
#else
	uint16_t diagRxSize;
	uint8_t addressing = 0;
	uint16_t index;
	uint16_t diagTxSize;
	size_t xBytesSent;

	for (;;)
	{
#ifdef ENABLE_UDS
		// Check UDS
		if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(addressing))
		{
			if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&addressing, sizeof(addressing), portMAX_DELAY) == sizeof(addressing))
			{
				if (xStreamBufferBytesAvailable(UdsRxDataStreamBufferHandle) >= sizeof(diagRxSize))
				{
					if (xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
					{
						if (diagRxSize <= 0xFFF)
						{
							index = 0;
							if (diagRxSize > 0U)
							{
								while (index != diagRxSize)
								{
									index += xStreamBufferReceive(UdsRxDataStreamBufferHandle, (void *)&diagRxbuf[index], diagRxSize - index, portMAX_DELAY);
								}
							}

							if (addressing == 0U)
							{
								RAMN_UDS_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
									xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
									if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
									{
#ifdef HANG_ON_ERRORS
										Error_Handler();
#endif
									}
									xTaskNotifyGive(RAMN_DiagTXHandle);
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
							else
							{
								RAMN_UDS_ProcessDiagPayloadFunctional(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
								if (diagTxSize > 0U)
								{
									uint8_t shouldSendAnswer = False;
									if (diagTxbuf[0] != 0x7F)
									{
										shouldSendAnswer = True;
									}
									else if ((diagTxSize > 2U) && (diagTxbuf[2] != UDS_NRC_SNS) && (diagTxbuf[2] != UDS_NRC_SFNS) && (diagTxbuf[2] != UDS_NRC_ROOR))
									{
										shouldSendAnswer = True;
									}

									if (shouldSendAnswer != False)
									{
										xBytesSent = xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
										xBytesSent += xStreamBufferSend(UdsTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
										if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
										{
#ifdef HANG_ON_ERRORS
											Error_Handler();
#endif
										}
										xTaskNotifyGive(RAMN_DiagTXHandle);
									}
								}
								RAMN_UDS_PerformPostAnswerActions(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
							}
						}
					}
				}
			}
		}
#endif
#ifdef ENABLE_KWP
		// Check KWP
		if (xStreamBufferBytesAvailable(KwpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(KwpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_KWP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(KwpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
#ifdef ENABLE_XCP
		// Check XCP
		if (xStreamBufferBytesAvailable(XcpRxDataStreamBufferHandle) >= sizeof(diagRxSize))
		{
			if (xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)&diagRxSize, sizeof(diagRxSize), portMAX_DELAY) == sizeof(diagRxSize))
			{
				if (diagRxSize <= 0xFFF)
				{
					index = 0;
					while (index != diagRxSize)
					{
						index += xStreamBufferReceive(XcpRxDataStreamBufferHandle, (void *)diagRxbuf + index, diagRxSize - index, portMAX_DELAY);
					}

					RAMN_XCP_ProcessDiagPayload(xTaskGetTickCount(), diagRxbuf, diagRxSize, diagTxbuf, &diagTxSize);
					if (diagTxSize > 0U)
					{
						xBytesSent = xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)&diagTxSize, sizeof(diagTxSize), portMAX_DELAY);
						xBytesSent += xStreamBufferSend(XcpTxDataStreamBufferHandle, (void *)diagTxbuf, diagTxSize, portMAX_DELAY);
						if (xBytesSent != (diagTxSize + sizeof(diagTxSize)))
						{
#ifdef HANG_ON_ERRORS
							Error_Handler();
#endif
						}
						xTaskNotifyGive(RAMN_DiagTXHandle);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagRXFunc */
}

/* USER CODE BEGIN Header_RAMN_DiagTXFunc */
/**
 * @brief Function implementing the RAMN_DiagTX thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_DiagTXFunc */
void RAMN_DiagTXFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_DiagTXFunc */
	/* Infinite loop */
#if !defined(ENABLE_DIAG)
	RAMN_CUSTOM_CustomTask6(argument);
#else
	uint16_t index = 0U;
	for (;;)
	{

#if defined(ENABLE_UDS)
		if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)&(RAMN_UDS_ISOTPHandler.txSize), sizeof(RAMN_UDS_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_UDS_ISOTPHandler.txSize))
			{
				if (RAMN_UDS_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_UDS_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(UdsTxDataStreamBufferHandle, (void *)(RAMN_UDS_ISOTPHandler.txData + index), RAMN_UDS_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_UDS_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_UDS_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(UdsTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_UDS_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_KWP)
		if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_KWP_ISOTPHandler.txSize))
		{
			if (xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)&(RAMN_KWP_ISOTPHandler.txSize), sizeof(RAMN_KWP_ISOTPHandler.txSize), portMAX_DELAY) == sizeof(RAMN_KWP_ISOTPHandler.txSize))
			{
				if (RAMN_KWP_ISOTPHandler.txSize <= 0xFFF) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != RAMN_KWP_ISOTPHandler.txSize)
					{
						index += xStreamBufferReceive(KwpTxDataStreamBufferHandle, (void *)(RAMN_KWP_ISOTPHandler.txData + index), RAMN_KWP_ISOTPHandler.txSize - index, portMAX_DELAY);
					}

					if (RAMN_ISOTP_RequestTx(&RAMN_KWP_ISOTPHandler, xTaskGetTickCount()) == RAMN_OK)
					{
						while (RAMN_KWP_Continue_TX(xTaskGetTickCount()) != True)
						{
							if (xStreamBufferBytesAvailable(KwpTxDataStreamBufferHandle) >= sizeof(RAMN_UDS_ISOTPHandler.txSize))
							{
								// We received another TX request even though the ongoing transfer isn't over.
								// User may be manually sending ISO-TP requests and forgot the FLOW CONTROL frames.
								// Consider the transfer over and move to next request.
								break;
							}
							osDelay(RAMN_DBC_RequestSilence ? RAMN_KWP_ISOTPHandler.targetST : SIM_LOOP_CLOCK_MS);
						}
					}
				}
			}
		}
#endif

#if defined(ENABLE_XCP)
		uint16_t diagTxSize;
		uint8_t XCP_payload[8];
		if (xStreamBufferBytesAvailable(XcpTxDataStreamBufferHandle) >= sizeof(diagTxSize))
		{
			if (xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)&(diagTxSize), sizeof(diagTxSize), portMAX_DELAY) == sizeof(diagTxSize))
			{
				if (diagTxSize <= 0x8) // TODO: empty buffer securely if overflow
				{
					index = 0U;
					while (index != diagTxSize)
					{
						index += xStreamBufferReceive(XcpTxDataStreamBufferHandle, (void *)(XCP_payload + index), diagTxSize - index, portMAX_DELAY);
					}

					while (RAMN_XCP_Continue_TX(xTaskGetTickCount(), XCP_payload, diagTxSize) != True)
					{
						osDelay(SIM_LOOP_CLOCK_MS);
					}
				}
			}
		}
#endif
		ulTaskNotifyTake(pdFALSE, portMAX_DELAY);
	}
#endif
	/* USER CODE END RAMN_DiagTXFunc */
}

/* USER CODE BEGIN Header_RAMN_SendUSBFunc */
/**
 * @brief Function implementing the RAMN_SendUSB thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_SendUSBFunc */
void RAMN_SendUSBFunc(void *argument)
{
	/* USER CODE BEGIN RAMN_SendUSBFunc */
#if defined(ENABLE_CDC)
	RAMN_USB_Init(&USBD_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	RAMN_CDC_Init(&USBD_RxStreamBufferHandle, &RAMN_ReceiveUSBHandle, &RAMN_SendUSBHandle);

#ifdef ENABLE_USB_AUTODETECT
	// We expect a notification from the serial close/open detection module
	// ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
	while (RAMN_CDC_GetTXStatus() != USBD_OK)
		osDelay(10U); // Wait for TX to be ready
#endif
	/* Infinite loop */
	for (;;)
	{
		size_t size = xStreamBufferReceive(USBD_TxStreamBufferHandle, USBIntermediateTxBuffer, sizeof(USBIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0U)
		{
			// Only sends if USB serial port is opened
#ifdef ENABLE_USB_AUTODETECT
			// Make sure no notification is pending
			ulTaskNotifyTake(pdTRUE, 0U);
			if (RAMN_USB_Config.serialOpened == True)
			{
#endif
				RAMN_USB_SendFromTask_Blocking(USBIntermediateTxBuffer, size);
#ifdef ENABLE_USB_AUTODETECT
			}
#endif
		}
	}
#elif defined(ENABLE_UART)
	RAMN_UART_Init(&UART_TxStreamBufferHandle, &RAMN_SendUSBHandle);
	for (;;)
	{
		size_t size = xStreamBufferReceive(UART_TxStreamBufferHandle, UARTIntermediateTxBuffer, sizeof(UARTIntermediateTxBuffer), portMAX_DELAY);
		if (size > 0)
		{
			HAL_UART_Transmit_IT(&hlpuart1, UARTIntermediateTxBuffer, size);
			ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
		}
	}
#else
	RAMN_CUSTOM_CustomTask2(argument);
#endif
	/* USER CODE END RAMN_SendUSBFunc */
}

/* USER CODE BEGIN Header_RAMN_RxTask2Func */
/**
 * @brief Function implementing the RAMN_RxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_RxTask2Func */
void RAMN_RxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_RxTask2Func */
	/* Infinite loop */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask3(argument);
#else
	BaseType_t ret;
	struct gs_host_frame *recvFrame;
	FDCAN_TxHeaderTypeDef CANTxHeader;
	uint8_t CANTxData[64];

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_RecvQueueHandle, &recvFrame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{

			// TODO implement CAN-FD

			// recvFrame->echo_id
			// recvFrame.flags
			// recvFrame.reserved

			CANTxHeader.Identifier = (recvFrame->can_id) & 0x1FFFFFFF;
			CANTxHeader.DataLength = recvFrame->can_dlc;
			if (recvFrame->can_id & CAN_RTR_FLAG)
				CANTxHeader.TxFrameType = FDCAN_REMOTE_FRAME;
			else
				CANTxHeader.TxFrameType = FDCAN_DATA_FRAME;

			if (recvFrame->can_id & CAN_EFF_FLAG)
				CANTxHeader.IdType = FDCAN_EXTENDED_ID;
			else
				CANTxHeader.IdType = FDCAN_STANDARD_ID;

			CANTxHeader.BitRateSwitch = FDCAN_BRS_OFF;
			CANTxHeader.ErrorStateIndicator = FDCAN_ESI_ACTIVE;
			CANTxHeader.FDFormat = FDCAN_CLASSIC_CAN;
			CANTxHeader.TxEventFifoControl = FDCAN_NO_TX_EVENTS;

			// CANTxHeader.MessageMarker = 0U;

			if (CANTxHeader.TxFrameType == FDCAN_DATA_FRAME)
			{
				RAMN_memcpy(CANTxData, recvFrame->data, DLCtoUINT8(recvFrame->can_dlc));
			}

			// TODO: implement better error reports
			if (RAMN_FDCAN_SendMessage(&CANTxHeader, CANTxData) == RAMN_OK)
			{
				// for host candump
				ret = xQueueSendToBack(RAMN_GSUSB_SendQueueHandle, &recvFrame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
					// Drop frame and return buffer to pool
					xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &recvFrame, portMAX_DELAY);
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_RxTask2Func */
}

/* USER CODE BEGIN Header_RAMN_TxTask2Func */
/**
 * @brief Function implementing the RAMN_TxTask2 thread.
 * @param argument: Not used
 * @retval None
 */
/* USER CODE END Header_RAMN_TxTask2Func */
void RAMN_TxTask2Func(void *argument)
{
	/* USER CODE BEGIN RAMN_TxTask2Func */
	// On ECU A, this task is used for gs_usb
#ifndef ENABLE_GSUSB
	RAMN_CUSTOM_CustomTask4(NULL);
#else
	BaseType_t ret;
	struct gs_host_frame *frame;

	/* Infinite loop */
	for (;;)
	{
		ret = xQueueReceive(RAMN_GSUSB_SendQueueHandle, &frame, portMAX_DELAY);
		if (ret != pdPASS)
		{
			RAMN_USB_Config.queueErrorCnt++;
		}
		else
		{
			if (USBD_GSUSB_SendFrame(hpcd_USB_FS.pData, frame) == USBD_OK)
			{
				// Return buffer to pool
				ret = xQueueSendToBack(RAMN_GSUSB_PoolQueueHandle, &frame, portMAX_DELAY);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
				else if (uxQueueMessagesWaiting(RAMN_GSUSB_PoolQueueHandle) == FDCAN_GetQueueSize())
				{
					xTaskNotifyGive(RAMN_SendCANHandle);
				}
			}
			else
			{
				// Send frame after
				ret = xQueueSendToFront(RAMN_GSUSB_SendQueueHandle, &frame, CAN_QUEUE_TIMEOUT);
				if (ret != pdPASS)
				{
					RAMN_USB_Config.queueErrorCnt++;
				}
			}
		}
	}
#endif
	/* USER CODE END RAMN_TxTask2Func */
}

/**
 * @brief  Period elapsed callback in non blocking mode
 * @note   This function is called  when TIM1 interrupt took place, inside
 * HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment
 * a global variable "uwTick" used as application time base.
 * @param  htim : TIM handle
 * @retval None
 */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	/* USER CODE BEGIN Callback 0 */
#ifdef GENERATE_RUNTIME_STATS
	if (htim->Instance == TIM7)
	{
		ulHighFrequencyTimerTicks++;
	}
	else
#endif
		/* USER CODE END Callback 0 */
		if (htim->Instance == TIM1)
		{
			HAL_IncTick();
		}
		/* USER CODE BEGIN Callback 1 */
		else if (htim->Instance == TIM6)
		{
			RAMN_CUSTOM_TIM6ISR(htim);
		}

	/* USER CODE END Callback 1 */
}

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
	 ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

```

- I wrapped the HAL call in `MX_LPUART1_UART_Init` so on Renode we ignore the return status instead of calling `Error_Handler`. Combined with the MSP USART1 clock/IRQ we added, this should let init proceed.

Rebuild and reload:
- mach clear
- i @/Users/yusufshaikh/Desktop/Projects/RAMN/firmware/RAMNV1/Debug/ramn_mac.resc
- start

If a new peripheral blocks next (e.g., USB), we‚Äôll guard it similarly under `RENODE_SIM` so you can reach tasks and see UART traffic.

---

**User**

0x801E2FC
12:04:28.5145 [INFO] cpu: Entering function xPortStartScheduler at 0x801E5C4
12:04:28.5146 [INFO] cpu: Entering function vStartFirstTask (entry) at 0x801E620
12:04:28.5216 [ERROR] cpu: write access to unsupported AArch32 64 bit system register cp:0 opc1:0 crm:0 (privilege)
12:04:28.7076 [ERROR] cpu: write access to unsupported AArch32 64 bit system register cp:0 opc1:0 crm:0 (privilege)


---

**Cursor**

- That error happens when the FreeRTOS port writes system registers the Renode Cortex‚ÄëM33 model doesn‚Äôt implement (typically TrustZone/FPU-related writes in vStartFirstTask). Renode then faults on ‚Äúunsupported AArch32 64-bit system register ‚Ä¶‚Äù as the scheduler starts.

Do this (Renode-friendly build):
- In your FreeRTOS config, disable features that poke those registers:
  - Set in FreeRTOSConfig.h: configENABLE_TRUSTZONE=0, configENABLE_FPU=0, configENABLE_MPU=0.
- Rebuild your Debug (with -DRENODE_SIM), then mach clear and reload the .resc.

If you still see the same error:
- Ensure you‚Äôre using the non-TrustZone CM33 FreeRTOS port files (not the TZ-aware ones).
- As a fallback, temporarily skip starting the scheduler on Renode and drive a minimal loop to confirm UART works; once UART is proven, we can re‚Äëenable RTOS after narrowing the exact register write causing the trap.

---

**User**

make the change

---

**Cursor**

I‚Äôll disable the FreeRTOS FPU usage only for RENODE_SIM in `Core/Inc/FreeRTOSConfig.h` so the scheduler doesn‚Äôt touch unsupported system registers in Renode. Then rebuild and reload.

```cpp
/* USER CODE BEGIN Header */
/*
 * FreeRTOS Kernel V10.3.1
 * Portion Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 * Portion Copyright (C) 2019 StMicroelectronics, Inc.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */
/* USER CODE END Header */

#ifndef FREERTOS_CONFIG_H
#define FREERTOS_CONFIG_H

/*-----------------------------------------------------------
 * Application specific definitions.
 *
 * These definitions should be adjusted for your particular hardware and
 * application requirements.
 *
 * These parameters and more are described within the 'configuration' section of the
 * FreeRTOS API documentation available on the FreeRTOS.org web site.
 *
 * See http://www.freertos.org/a00110.html
 *----------------------------------------------------------*/

/* USER CODE BEGIN Includes */
/* Section where include file can be added */
/* USER CODE END Includes */

/* Ensure definitions are only used by the compiler, and not by the assembler. */
#if defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)
  #include <stdint.h>
  extern uint32_t SystemCoreClock;
/* USER CODE BEGIN 0 */
  extern void configureTimerForRunTimeStats(void);
  extern unsigned long getRunTimeCounterValue(void);
/* USER CODE END 0 */
#endif
#ifndef CMSIS_device_header
#define CMSIS_device_header "stm32l5xx.h"
#endif /* CMSIS_device_header */

/*-------------------- STM32L5 specific defines -------------------*/
#define configENABLE_TRUSTZONE                   0
#define configRUN_FREERTOS_SECURE_ONLY           0
#define configENABLE_FPU                         1
#define configENABLE_MPU                         0

/* On Renode, avoid touching system registers not modeled by disabling FPU/MPU/TZ */
#ifdef RENODE_SIM
#undef configENABLE_FPU
#define configENABLE_FPU                         0
#undef configENABLE_MPU
#define configENABLE_MPU                         0
#undef configENABLE_TRUSTZONE
#define configENABLE_TRUSTZONE                   0
#endif

#define configUSE_PREEMPTION                     1
#define configSUPPORT_STATIC_ALLOCATION          1
#define configSUPPORT_DYNAMIC_ALLOCATION         1
#define configUSE_IDLE_HOOK                      0
#define configUSE_TICK_HOOK                      0
#define configCPU_CLOCK_HZ                       ( SystemCoreClock )
#define configTICK_RATE_HZ                       ((TickType_t)1000)
#define configMAX_PRIORITIES                     ( 56 )
#define configMINIMAL_STACK_SIZE                 ((uint16_t)256)
#define configTOTAL_HEAP_SIZE                    ((size_t)6144)
#define configMAX_TASK_NAME_LEN                  ( 16 )
#define configGENERATE_RUN_TIME_STATS            1
#define configUSE_TRACE_FACILITY                 1
#define configUSE_STATS_FORMATTING_FUNCTIONS     1
#define configUSE_16_BIT_TICKS                   0
#define configUSE_MUTEXES                        1
#define configQUEUE_REGISTRY_SIZE                8
#define configCHECK_FOR_STACK_OVERFLOW           2
#define configUSE_RECURSIVE_MUTEXES              1
#define configUSE_COUNTING_SEMAPHORES            1
#define configUSE_PORT_OPTIMISED_TASK_SELECTION  0
/* USER CODE BEGIN MESSAGE_BUFFER_LENGTH_TYPE */
/* Defaults to size_t for backward compatibility, but can be changed
   if lengths will always be less than the number of bytes in a size_t. */
#define configMESSAGE_BUFFER_LENGTH_TYPE         size_t
/* USER CODE END MESSAGE_BUFFER_LENGTH_TYPE */

/* Co-routine definitions. */
#define configUSE_CO_ROUTINES                    0
#define configMAX_CO_ROUTINE_PRIORITIES          ( 2 )

/* Software timer definitions. */
#define configUSE_TIMERS                         1
#define configTIMER_TASK_PRIORITY                ( 2 )
#define configTIMER_QUEUE_LENGTH                 10
#define configTIMER_TASK_STACK_DEPTH             512

/* The following flag must be enabled only when using newlib */
#define configUSE_NEWLIB_REENTRANT          1

/* CMSIS-RTOS V2 flags */
#define configUSE_OS2_THREAD_SUSPEND_RESUME  1
#define configUSE_OS2_THREAD_ENUMERATE       1
#define configUSE_OS2_EVENTFLAGS_FROM_ISR    1
#define configUSE_OS2_THREAD_FLAGS           1
#define configUSE_OS2_TIMER                  1
#define configUSE_OS2_MUTEX                  1

/* Set the following definitions to 1 to include the API function, or zero
to exclude the API function. */
#define INCLUDE_vTaskPrioritySet             1
#define INCLUDE_uxTaskPriorityGet            1
#define INCLUDE_vTaskDelete                  1
#define INCLUDE_vTaskCleanUpResources        0
#define INCLUDE_vTaskSuspend                 1
#define INCLUDE_vTaskDelayUntil              1
#define INCLUDE_vTaskDelay                   1
#define INCLUDE_xTaskGetSchedulerState       1
#define INCLUDE_xTimerPendFunctionCall       1
#define INCLUDE_xQueueGetMutexHolder         1
#define INCLUDE_uxTaskGetStackHighWaterMark  1
#define INCLUDE_xTaskGetCurrentTaskHandle    1
#define INCLUDE_eTaskGetState                1

/*
 * The CMSIS-RTOS V2 FreeRTOS wrapper is dependent on the heap implementation used
 * by the application thus the correct define need to be enabled below
 */
#define USE_FreeRTOS_HEAP_4

/* Cortex-M specific definitions. */
#ifdef __NVIC_PRIO_BITS
 /* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
 #define configPRIO_BITS         __NVIC_PRIO_BITS
#else
 #define configPRIO_BITS         3
#endif

/* The lowest interrupt priority that can be used in a call to a "set priority"
function. */
#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY   7

/* The highest interrupt priority that can be used by any interrupt service
routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
PRIORITY THAN THIS! (higher priorities are lower numeric values. */
#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5

/* Interrupt priorities used by the kernel port layer itself.  These are generic
to all Cortex-M ports, and do not rely on any particular library functions. */
#define configKERNEL_INTERRUPT_PRIORITY 		( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )
/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
#define configMAX_SYSCALL_INTERRUPT_PRIORITY 	( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS) )

/* Normal assert() semantics without relying on the provision of an assert.h
header file. */
/* USER CODE BEGIN 1 */
#define configASSERT( x ) if ((x) == 0) {taskDISABLE_INTERRUPTS(); for( ;; );}
/* USER CODE END 1 */

#define SysTick_Handler xPortSysTickHandler

/* USER CODE BEGIN 2 */
/* Definitions needed when configGENERATE_RUN_TIME_STATS is on */
#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS configureTimerForRunTimeStats
#define portGET_RUN_TIME_COUNTER_VALUE getRunTimeCounterValue
/* USER CODE END 2 */

/* USER CODE BEGIN Defines */
/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */
/* USER CODE END Defines */

#endif /* FREERTOS_CONFIG_H */

```

- I disabled FreeRTOS FPU/MPU/TrustZone for `RENODE_SIM` in `Core/Inc/FreeRTOSConfig.h`. This prevents the scheduler from writing unsupported system registers in Renode‚Äôs M33 model.

Rebuild (with -DRENODE_SIM) and reload the .resc. You should now get past `vStartFirstTask` without the ‚Äúunsupported AArch32 64 bit system register‚Äù errors.

---

**User**

12:11:44.9752 [INFO] cpu: Entering function xPortStartScheduler at 0x801E590
12:11:44.9753 [INFO] cpu: Entering function vStartFirstTask (entry) at 0x801E5E0
12:11:44.9815 [ERROR] cpu: write access to unsupported AArch32 64 bit system register cp:0 opc1:0 crm:0 (privilege)
12:11:45.3445 [ERROR] cpu: write access to unsupported AArch32 64 bit system register cp:0 opc1:0 crm:0 (privilege)

isnt ramn arm

---

**Cursor**

Yes, it‚Äôs ARM (Cortex‚ÄëM33, AArch32). The error is from the FreeRTOS CM33 port writing ARMv8‚ÄëM system registers (e.g., stack limit/TrustZone-related) that Renode‚Äôs M33 model doesn‚Äôt implement; Renode traps them as ‚Äúunsupported AArch32 64‚Äëbit system register.‚Äù

What to do next (pick one):
- Switch FreeRTOS port to ARM_CM3 for Renode runs: point the project to portable/GCC/ARM_CM3 port files (or select ‚ÄúCortex‚ÄëM3‚Äù port in IDE). This avoids the v8‚ÄëM register writes.
- Patch the CM33_NTZ port for Renode: under RENODE_SIM, guard the MSPLIM/PSPLIM (and similar) writes in portasm.c/port.c.
- Quick sanity path: under RENODE_SIM, skip starting the scheduler and run a simple while(1) that periodically transmits over USART1 to verify UART output, then re‚Äëenable RTOS after switching the port.

